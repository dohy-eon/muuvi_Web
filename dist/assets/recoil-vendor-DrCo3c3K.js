import{R as Z,r as jo}from"./react-vendor-BCvJ4SZV.js";var In={};function qo(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Zo=qo,M=Zo;function Yo(e){return!!e&&typeof e.then=="function"}var K=Yo;function Xo(e,t){if(e!=null)return e;throw M(t??"Got unexpected null or undefined")}var j=Xo;function V(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class dt{getValue(){throw M("BaseLoadable")}toPromise(){throw M("BaseLoadable")}valueMaybe(){throw M("BaseLoadable")}valueOrThrow(){throw M(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw M("BaseLoadable")}promiseOrThrow(){throw M(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw M("BaseLoadable")}errorOrThrow(){throw M(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw M("BaseLoadable")}}class Jo extends dt{constructor(t){super(),V(this,"state","hasValue"),V(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return K(n)?Ee(n):Ie(n)?n:Ze(n)}catch(n){return K(n)?Ee(n.next(()=>this.map(t))):ft(n)}}}class Qo extends dt{constructor(t){super(),V(this,"state","hasError"),V(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Un extends dt{constructor(t){super(),V(this,"state","loading"),V(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ee(this.contents.then(n=>{const o=t(n);if(Ie(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(K(n))return n.then(()=>this.map(t).contents);throw n}))}}function Ze(e){return Object.freeze(new Jo(e))}function ft(e){return Object.freeze(new Qo(e))}function Ee(e){return Object.freeze(new Un(e))}function Pn(){return Object.freeze(new Un(new Promise(()=>{})))}function er(e){return e.every(t=>t.state==="hasValue")?Ze(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?ft(j(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ee(Promise.all(e.map(t=>t.contents)))}function xn(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Ie(r)?r:K(r)?Ee(r):Ze(r)),o=er(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,i,u)=>({...a,[i]:r[u]}),{}))}function Ie(e){return e instanceof dt}const tr={of:e=>K(e)?Ee(e):Ie(e)?e:Ze(e),error:e=>ft(e),loading:()=>Pn(),all:xn,isLoadable:Ie};var Ae={loadableWithValue:Ze,loadableWithError:ft,loadableWithPromise:Ee,loadableLoading:Pn,loadableAll:xn,isLoadable:Ie,RecoilLoadable:tr},nr=Ae.loadableWithValue,or=Ae.loadableWithError,rr=Ae.loadableWithPromise,ar=Ae.loadableLoading,sr=Ae.loadableAll,ir=Ae.isLoadable,lr=Ae.RecoilLoadable,Ye=Object.freeze({__proto__:null,loadableWithValue:nr,loadableWithError:or,loadableWithPromise:rr,loadableLoading:ar,loadableAll:sr,isLoadable:ir,RecoilLoadable:lr});const xt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function cr(e,t){var n,o;const r=(n=In[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw M(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function ur(e,t){var n;const o=(n=In[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function dr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(cr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{xt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),ur("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{xt.RECOIL_GKS_ENABLED.add(n)})}))}dr();var Xe=xt;function ht(e){return Xe.RECOIL_GKS_ENABLED.has(e)}ht.setPass=e=>{Xe.RECOIL_GKS_ENABLED.add(e)};ht.setFail=e=>{Xe.RECOIL_GKS_ENABLED.delete(e)};ht.clear=()=>{Xe.RECOIL_GKS_ENABLED.clear()};var F=ht;function fr(e,t,{error:n}={}){return null}var hr=fr,ie=hr,Vt,$t,Mt;const vr=(Vt=Z.createMutableSource)!==null&&Vt!==void 0?Vt:Z.unstable_createMutableSource,On=($t=Z.useMutableSource)!==null&&$t!==void 0?$t:Z.unstable_useMutableSource,Gt=(Mt=Z.useSyncExternalStore)!==null&&Mt!==void 0?Mt:Z.unstable_useSyncExternalStore;let fn=!1;function pr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,r=((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null;return Gt&&!r&&!fn&&(fn=!0,ie()),r}function _r(){return F("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:F("recoil_sync_external_store")&&Gt!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:F("recoil_mutable_source")&&On!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?F("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:F("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}var Ht={createMutableSource:vr,useMutableSource:On,useSyncExternalStore:Gt,currentRendererSupportsUseSyncExternalStore:pr,reactMode:_r};class jt{constructor(t){V(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class Bn extends jt{}class zn extends jt{}function mr(e){return e instanceof Bn||e instanceof zn}var vt={AbstractRecoilValue:jt,RecoilState:Bn,RecoilValueReadOnly:zn,isRecoilValue:mr},yr=vt.AbstractRecoilValue,Sr=vt.RecoilState,gr=vt.RecoilValueReadOnly,Rr=vt.isRecoilValue,Te=Object.freeze({__proto__:null,AbstractRecoilValue:yr,RecoilState:Sr,RecoilValueReadOnly:gr,isRecoilValue:Rr});function br(e,...t){}var wr=br,Fn=wr;function Er(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var pt=Er;class Wn{}const Tr=new Wn,Ue=new Map,qt=new Map;function Ar(e){return pt(e,t=>j(qt.get(t)))}function Nr(e){if(Ue.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function Lr(e){Xe.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&Nr(e.key),Ue.set(e.key,e);const t=e.set==null?new Te.RecoilValueReadOnly(e.key):new Te.RecoilState(e.key);return qt.set(e.key,t),t}class Cr extends Error{}function Vr(e){const t=Ue.get(e);if(t==null)throw new Cr(`Missing definition for RecoilValue: "${e}""`);return t}function $r(e){return Ue.get(e)}const ct=new Map;function Mr(e){var t;if(!F("recoil_memory_managament_2020"))return;const n=Ue.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ue.delete(e),(o=Kn(e))===null||o===void 0||o(),ct.delete(e)}}function kr(e,t){F("recoil_memory_managament_2020")&&(t===void 0?ct.delete(e):ct.set(e,t))}function Kn(e){return ct.get(e)}var _e={recoilValues:qt,registerNode:Lr,getNode:Vr,getNodeMaybe:$r,deleteNodeConfigIfPossible:Mr,setConfigDeletionHandler:kr,getConfigDeletionHandler:Kn,recoilValuesForKeys:Ar,DefaultValue:Wn,DEFAULT_VALUE:Tr};function Dr(e,t){t()}var Ir={enqueueExecution:Dr};function Ur(e,t){return t={exports:{}},e(t,t.exports),t.exports}var Pr=Ur(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(l){return typeof l}:function(l){return l&&typeof Symbol=="function"&&l.constructor===Symbol&&l!==Symbol.prototype?"symbol":typeof l},n={},o=5,r=Math.pow(2,o),a=r-1,i=r/2,u=r/4,d={},f=function(s){return function(){return s}},p=n.hash=function(l){var s=typeof l>"u"?"undefined":t(l);if(s==="number")return l;s!=="string"&&(l+="");for(var h=0,m=0,y=l.length;m<y;++m){var S=l.charCodeAt(m);h=(h<<5)-h+S|0}return h},g=function(s){return s-=s>>1&1431655765,s=(s&858993459)+(s>>2&858993459),s=s+(s>>4)&252645135,s+=s>>8,s+=s>>16,s&127},I=function(s,h){return h>>>s&a},L=function(s){return 1<<s},E=function(s,h){return g(s&h-1)},$=function(s,h,m,y){var S=y;if(!s){var N=y.length;S=new Array(N);for(var T=0;T<N;++T)S[T]=y[T]}return S[h]=m,S},Q=function(s,h,m){var y=m.length-1,S=0,N=0,T=m;if(s)S=N=h;else for(T=new Array(y);S<h;)T[N++]=m[S++];for(++S;S<=y;)T[N++]=m[S++];return s&&(T.length=y),T},te=function(s,h,m,y){var S=y.length;if(s){for(var N=S;N>=h;)y[N--]=y[N];return y[h]=m,y}for(var T=0,A=0,D=new Array(S+1);T<h;)D[A++]=y[T++];for(D[h]=m;T<S;)D[++A]=y[T++];return D},w=1,U=2,Y=3,z=4,G={__hamt_isEmpty:!0},q=function(s){return s===G||s&&s.__hamt_isEmpty},re=function(s,h,m,y){return{type:w,edit:s,hash:h,key:m,value:y,_modify:Ve}},ye=function(s,h,m){return{type:U,edit:s,hash:h,children:m,_modify:$e}},J=function(s,h,m){return{type:Y,edit:s,mask:h,children:m,_modify:P}},ue=function(s,h,m){return{type:z,edit:s,size:h,children:m,_modify:B}},Ce=function(s){return s===G||s.type===w||s.type===U},X=function(s,h,m,y,S){for(var N=[],T=y,A=0,D=0;T;++D)T&1&&(N[D]=S[A++]),T>>>=1;return N[h]=m,ue(s,A+1,N)},le=function(s,h,m,y){for(var S=new Array(h-1),N=0,T=0,A=0,D=y.length;A<D;++A)if(A!==m){var H=y[A];H&&!q(H)&&(S[N++]=H,T|=1<<A)}return J(s,T,S)},be=function l(s,h,m,y,S,N){if(m===S)return ye(s,m,[N,y]);var T=I(h,m),A=I(h,S);return J(s,L(T)|L(A),T===A?[l(s,h+o,m,y,S,N)]:T<A?[y,N]:[N,y])},de=function(s,h,m,y,S,N,T,A){for(var D=S.length,H=0;H<D;++H){var se=S[H];if(m(T,se.key)){var oe=se.value,fe=N(oe);return fe===oe?S:fe===d?(--A.value,Q(s,H,S)):$(s,H,re(h,y,T,fe),S)}}var he=N();return he===d?S:(++A.value,$(s,D,re(h,y,T,he),S))},Se=function(s,h){return s===h.edit},Ve=function(s,h,m,y,S,N,T){if(h(N,this.key)){var A=y(this.value);return A===this.value?this:A===d?(--T.value,G):Se(s,this)?(this.value=A,this):re(s,S,N,A)}var D=y();return D===d?this:(++T.value,be(s,m,this.hash,this,S,re(s,S,N,D)))},$e=function(s,h,m,y,S,N,T){if(S===this.hash){var A=Se(s,this),D=de(A,s,h,this.hash,this.children,y,N,T);return D===this.children?this:D.length>1?ye(s,this.hash,D):D[0]}var H=y();return H===d?this:(++T.value,be(s,m,this.hash,this,S,re(s,S,N,H)))},P=function(s,h,m,y,S,N,T){var A=this.mask,D=this.children,H=I(m,S),se=L(H),oe=E(A,se),fe=A&se,he=fe?D[oe]:G,Me=he._modify(s,h,m+o,y,S,N,T);if(he===Me)return this;var nt=Se(s,this),Oe=A,Be=void 0;if(fe&&q(Me)){if(Oe&=~se,!Oe)return G;if(D.length<=2&&Ce(D[oe^1]))return D[oe^1];Be=Q(nt,oe,D)}else if(!fe&&!q(Me)){if(D.length>=i)return X(s,H,Me,A,D);Oe|=se,Be=te(nt,oe,Me,D)}else Be=$(nt,oe,Me,D);return nt?(this.mask=Oe,this.children=Be,this):J(s,Oe,Be)},B=function(s,h,m,y,S,N,T){var A=this.size,D=this.children,H=I(m,S),se=D[H],oe=(se||G)._modify(s,h,m+o,y,S,N,T);if(se===oe)return this;var fe=Se(s,this),he=void 0;if(q(se)&&!q(oe))++A,he=$(fe,H,oe,D);else if(!q(se)&&q(oe)){if(--A,A<=u)return le(s,A,H,D);he=$(fe,H,G,D)}else he=$(fe,H,oe,D);return fe?(this.size=A,this.children=he,this):ue(s,A,he)};G._modify=function(l,s,h,m,y,S,N){var T=m();return T===d?G:(++N.value,re(l,y,S,T))};function c(l,s,h,m,y){this._editable=l,this._edit=s,this._config=h,this._root=m,this._size=y}c.prototype.setTree=function(l,s){return this._editable?(this._root=l,this._size=s,this):l===this._root?this:new c(this._editable,this._edit,this._config,l,s)};var v=n.tryGetHash=function(l,s,h,m){for(var y=m._root,S=0,N=m._config.keyEq;;)switch(y.type){case w:return N(h,y.key)?y.value:l;case U:{if(s===y.hash)for(var T=y.children,A=0,D=T.length;A<D;++A){var H=T[A];if(N(h,H.key))return H.value}return l}case Y:{var se=I(S,s),oe=L(se);if(y.mask&oe){y=y.children[E(y.mask,oe)],S+=o;break}return l}case z:{if(y=y.children[I(S,s)],y){S+=o;break}return l}default:return l}};c.prototype.tryGetHash=function(l,s,h){return v(l,s,h,this)};var _=n.tryGet=function(l,s,h){return v(l,h._config.hash(s),s,h)};c.prototype.tryGet=function(l,s){return _(l,s,this)};var C=n.getHash=function(l,s,h){return v(void 0,l,s,h)};c.prototype.getHash=function(l,s){return C(l,s,this)},n.get=function(l,s){return v(void 0,s._config.hash(l),l,s)},c.prototype.get=function(l,s){return _(s,l,this)};var R=n.has=function(l,s,h){return v(d,l,s,h)!==d};c.prototype.hasHash=function(l,s){return R(l,s,this)};var k=n.has=function(l,s){return R(s._config.hash(l),l,s)};c.prototype.has=function(l){return k(l,this)};var b=function(s,h){return s===h};n.make=function(l){return new c(0,0,{keyEq:l&&l.keyEq||b,hash:l&&l.hash||p},G,0)},n.empty=n.make();var x=n.isEmpty=function(l){return l&&!!q(l._root)};c.prototype.isEmpty=function(){return x(this)};var W=n.modifyHash=function(l,s,h,m){var y={value:m._size},S=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,l,s,h,y);return m.setTree(S,y.value)};c.prototype.modifyHash=function(l,s,h){return W(h,l,s,this)};var ee=n.modify=function(l,s,h){return W(l,h._config.hash(s),s,h)};c.prototype.modify=function(l,s){return ee(s,l,this)};var O=n.setHash=function(l,s,h,m){return W(f(h),l,s,m)};c.prototype.setHash=function(l,s,h){return O(l,s,h,this)};var ne=n.set=function(l,s,h){return O(h._config.hash(l),l,s,h)};c.prototype.set=function(l,s){return ne(l,s,this)};var me=f(d),ce=n.removeHash=function(l,s,h){return W(me,l,s,h)};c.prototype.removeHash=c.prototype.deleteHash=function(l,s){return ce(l,s,this)};var ae=n.remove=function(l,s){return ce(s._config.hash(l),l,s)};c.prototype.remove=c.prototype.delete=function(l){return ae(l,this)};var tt=n.beginMutation=function(l){return new c(l._editable+1,l._edit+1,l._config,l._root,l._size)};c.prototype.beginMutation=function(){return tt(this)};var ln=n.endMutation=function(l){return l._editable=l._editable&&l._editable-1,l};c.prototype.endMutation=function(){return ln(this)};var Po=n.mutate=function(l,s){var h=tt(s);return l(h),ln(h)};c.prototype.mutate=function(l){return Po(l,this)};var Nt=function(s){return s&&cn(s[0],s[1],s[2],s[3],s[4])},cn=function(s,h,m,y,S){for(;m<s;){var N=h[m++];if(N&&!q(N))return un(N,y,[s,h,m,y,S])}return Nt(S)},un=function(s,h,m){switch(s.type){case w:return{value:h(s),rest:m};case U:case z:case Y:var y=s.children;return cn(y.length,y,0,h,m);default:return Nt(m)}},xo={done:!0};function Lt(l){this.v=l}Lt.prototype.next=function(){if(!this.v)return xo;var l=this.v;return this.v=Nt(l.rest),l},Lt.prototype[Symbol.iterator]=function(){return this};var Ct=function(s,h){return new Lt(un(s._root,h))},Oo=function(s){return[s.key,s.value]},Bo=n.entries=function(l){return Ct(l,Oo)};c.prototype.entries=c.prototype[Symbol.iterator]=function(){return Bo(this)};var zo=function(s){return s.key},Fo=n.keys=function(l){return Ct(l,zo)};c.prototype.keys=function(){return Fo(this)};var Wo=function(s){return s.value},Ko=n.values=c.prototype.values=function(l){return Ct(l,Wo)};c.prototype.values=function(){return Ko(this)};var dn=n.fold=function(l,s,h){var m=h._root;if(m.type===w)return l(s,m.value,m.key);for(var y=[m.children],S=void 0;S=y.pop();)for(var N=0,T=S.length;N<T;){var A=S[N++];A&&A.type&&(A.type===w?s=l(s,A.value,A.key):y.push(A.children))}return s};c.prototype.fold=function(l,s){return dn(l,s,this)};var Go=n.forEach=function(l,s){return dn(function(h,m,y){return l(m,y,s)},null,s)};c.prototype.forEach=function(l){return Go(l,this)};var Ho=n.count=function(l){return l._size};c.prototype.count=function(){return Ho(this)},Object.defineProperty(c.prototype,"size",{get:c.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class xr{constructor(t){V(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return Yt(this)}toMap(){return new Map(this._map)}}class Zt{constructor(t){if(V(this,"_hamt",Pr.empty.beginMutation()),t instanceof Zt){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return Yt(this)}toMap(){return new Map(this._hamt)}}function Yt(e){return F("recoil_hamt_2020")?new Zt(e):new xr(e)}var Or={persistentMap:Yt},Br=Or.persistentMap,zr=Object.freeze({__proto__:null,persistentMap:Br});function Fr(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var hn=Fr;function Wr(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var vn=Wr;function Kr(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function Gr(e){return{nodeDeps:vn(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:vn(e.nodeToNodeSubscriptions,t=>new Set(t))}}function kt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,i=r.get(e);if(i&&o&&i!==o.nodeDeps.get(e))return;r.set(e,t);const u=i==null?t:hn(t,i);for(const d of u)a.has(d)||a.set(d,new Set),j(a.get(d)).add(e);if(i){const d=hn(i,t);for(const f of d){if(!a.has(f))return;const p=j(a.get(f));p.delete(e),p.size===0&&a.delete(f)}}}function Hr(e,t,n,o){var r,a,i,u;const d=n.getState();o===d.currentTree.version||o===((r=d.nextTree)===null||r===void 0?void 0:r.version)||o===((a=d.previousTree)===null||a===void 0?void 0:a.version)||ie();const f=n.getGraph(o);if(kt(e,t,f),o===((i=d.previousTree)===null||i===void 0?void 0:i.version)){const g=n.getGraph(d.currentTree.version);kt(e,t,g,f)}if(o===((u=d.previousTree)===null||u===void 0?void 0:u.version)||o===d.currentTree.version){var p;const g=(p=d.nextTree)===null||p===void 0?void 0:p.version;if(g!==void 0){const I=n.getGraph(g);kt(e,t,I,f)}}}var Je={cloneGraph:Gr,graph:Kr,saveDepsToStore:Hr};let jr=0;const qr=()=>jr++;let Zr=0;const Yr=()=>Zr++;let Xr=0;const Jr=()=>Xr++;var _t={getNextTreeStateVersion:qr,getNextStoreID:Yr,getNextComponentID:Jr};const{persistentMap:pn}=zr,{graph:Qr}=Je,{getNextTreeStateVersion:Gn}=_t;function ea(){const e=Gn();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:pn(),nonvalidatedAtoms:pn()}}function ta(){const e=ea();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Qr()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var Hn={makeEmptyStoreState:ta,getNextTreeStateVersion:Gn};class na{}var Xt={RetentionZone:na};function oa(e,t){const n=new Set(e);return n.add(t),n}var ra={setByAddingToSet:oa};function*aa(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var Jt=aa;function sa(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var jn=sa;const{getNode:Qe,getNodeMaybe:ia,recoilValuesForKeys:_n}=_e,{RetentionZone:mn}=Xt,{setByAddingToSet:la}=ra,ca=Object.freeze(new Set);class ua extends Error{}function da(e,t,n){if(!F("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let i=o.get(a);i||o.set(a,i=new Set),i.add(t)}if(n instanceof mn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!F("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function i(u){const d=a.nodesRetainedByZone.get(u);d==null||d.delete(t),d&&d.size===0&&a.nodesRetainedByZone.delete(u)}if(n instanceof mn)i(n);else if(Array.isArray(n))for(const u of n)i(u)}}function Qt(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Qe(n),i=da(e,n,a.retainedBy),u=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{u(),i()})}function fa(e,t,n){Qt(e,e.getState().currentTree,t,n)}function ha(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function va(e,t,n){return Qt(e,t,n,"get"),Qe(n).get(e,t)}function qn(e,t,n){return Qe(n).peek(e,t)}function pa(e,t,n){var o;const r=ia(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:la(e.dirtyAtoms,t)}}function _a(e,t,n,o){const r=Qe(n);if(r.set==null)throw new ua(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Qt(e,t,n,"set"),a(e,t,o)}function ma(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=Qe(n).nodeType;return jn({type:a},{loadable:()=>qn(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var i;return _n((i=r.nodeDeps.get(n))!==null&&i!==void 0?i:[])},subscribers:()=>{var i,u;return{nodes:_n(Jt(Zn(e,t,new Set([n])),d=>d!==n)),components:pt((i=(u=o.nodeToComponentSubscriptions.get(n))===null||u===void 0?void 0:u.values())!==null&&i!==void 0?i:[],([d])=>({name:d}))}}})}function Zn(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let u=r.pop();u;u=r.pop()){var i;o.add(u);const d=(i=a.nodeToNodeSubscriptions.get(u))!==null&&i!==void 0?i:ca;for(const f of d)o.has(f)||r.push(f)}return o}var Ne={getNodeLoadable:va,peekNodeLoadable:qn,setNodeValue:_a,initializeNode:fa,cleanUpNode:ha,setUnvalidatedAtomValue_DEPRECATED:pa,peekNodeInfo:ma,getDownstreamNodes:Zn};let Yn=null;function ya(e){Yn=e}function Sa(){var e;(e=Yn)===null||e===void 0||e()}var Xn={setInvalidateMemoizedSnapshot:ya,invalidateMemoizedSnapshot:Sa};const{getDownstreamNodes:ga,getNodeLoadable:Jn,setNodeValue:Ra}=Ne,{getNextComponentID:ba}=_t,{getNode:wa,getNodeMaybe:Qn}=_e,{DefaultValue:en}=_e,{reactMode:Ea}=Ht,{AbstractRecoilValue:Ta,RecoilState:fc,RecoilValueReadOnly:hc,isRecoilValue:vc}=Te,{invalidateMemoizedSnapshot:Aa}=Xn;function Na(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version)||ie();const i=Jn(e,n,t);return i.state==="loading"&&i.contents.catch(()=>{}),i}function La(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof en?n.delete(r):n.set(r,o)}),n}function Ca(e,t,{key:n},o){if(typeof o=="function"){const r=Jn(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw ie(),M(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Va(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,i=Ca(e,t,r,a),u=Ra(e,t,r.key,i);for(const[d,f]of u.entries())Ot(t,d,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Ot(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,i=Qn(r);i==null||(o=i.invalidate)===null||o===void 0||o.call(i,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else ie(`Unknown action ${n.type}`)}function Ot(e,t,n){n.state==="hasValue"&&n.contents instanceof en?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function eo(e,t){e.replaceState(n=>{const o=to(n);for(const r of t)Va(e,o,r);return no(e,o),Aa(),o})}function mt(e,t){if(je.length){const n=je[je.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else eo(e,[t])}const je=[];function $a(){const e=new Map;return je.push(e),()=>{for(const[n,o]of e)eo(n,o);je.pop()!==e&&ie()}}function to(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function no(e,t){const n=ga(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=Qn(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function oo(e,t,n){mt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Ma(e,t,n){if(n instanceof en)return oo(e,t,n);mt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function ka(e,t){mt(e,{type:"markModified",recoilValue:t})}function Da(e,t,n){mt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Ia(e,{key:t},n,o=null){const r=ba(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),j(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const i=Ea();if(i.early&&(i.mode==="LEGACY"||i.mode==="MUTABLE_SOURCE")){const u=e.getState().nextTree;u&&u.dirtyAtoms.has(t)&&n(u)}return{release:()=>{const u=e.getState(),d=u.nodeToComponentSubscriptions.get(t);if(d===void 0||!d.has(r)){ie();return}d.delete(r),d.size===0&&u.nodeToComponentSubscriptions.delete(t)}}}function Ua(e,t){var n;const{currentTree:o}=e.getState(),r=wa(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var ge={AbstractRecoilValue:Ta,getRecoilValueAsLoadable:Na,setRecoilValue:oo,setRecoilValueLoadable:Ma,markRecoilValueModified:ka,setUnvalidatedRecoilValue:Da,subscribeToRecoilValue:Ia,applyAtomValueWrites:La,batchStart:$a,writeLoadableToTreeState:Ot,invalidateDownstreams:no,copyTreeState:to,refreshRecoilValue:Ua};function Pa(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var xa=Pa;const{cleanUpNode:Oa}=Ne,{deleteNodeConfigIfPossible:Ba,getNode:ro}=_e,{RetentionZone:ao}=Xt,za=12e4,so=new Set;function io(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree){ie();return}const r=new Set;for(const i of t)if(i instanceof ao)for(const u of Ga(n,i))r.add(u);else r.add(i);const a=Fa(e,r);for(const i of a)Ka(e,o,i)}function Fa(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return u(t),a;function u(d){const f=new Set,p=Wa(e,o,d,a,i);for(const E of p){var g;if(ro(E).retainedBy==="recoilRoot"){i.add(E);continue}if(((g=n.retention.referenceCounts.get(E))!==null&&g!==void 0?g:0)>0){i.add(E);continue}if(lo(E).some(Q=>n.retention.referenceCounts.get(Q))){i.add(E);continue}const $=r.nodeToNodeSubscriptions.get(E);if($&&xa($,Q=>i.has(Q))){i.add(E);continue}a.add(E),f.add(E)}const I=new Set;for(const E of f)for(const $ of(L=r.nodeDeps.get(E))!==null&&L!==void 0?L:so){var L;a.has($)||I.add($)}I.size&&u(I)}}function Wa(e,t,n,o,r){const a=e.getGraph(t.version),i=[],u=new Set;for(;n.size>0;)d(j(n.values().next().value));return i;function d(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(u.has(f))return;const p=a.nodeToNodeSubscriptions.get(f);if(p)for(const g of p)d(g);u.add(f),n.delete(f),i.push(f)}}function Ka(e,t,n){if(!F("recoil_memory_managament_2020"))return;Oa(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=lo(n);for(const d of r){var a;(a=o.retention.nodesRetainedByZone.get(d))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const d=i.nodeDeps.get(n);if(d!==void 0){i.nodeDeps.delete(n);for(const f of d){var u;(u=i.nodeToNodeSubscriptions.get(f))===null||u===void 0||u.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}Ba(n)}function Ga(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:so}function lo(e){const t=ro(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof ao?[t]:t}function Ha(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):io(e,new Set([t]))}function ja(e,t,n){var o;if(!F("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?qa(e,t):r.set(t,a)}function qa(e,t){if(!F("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Ha(e,t)}function Za(e){if(!F("recoil_memory_managament_2020"))return;const t=e.getState();io(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Ya(e){return e===void 0?"recoilRoot":e}var Pe={SUSPENSE_TIMEOUT_MS:za,updateRetainCount:ja,releaseScheduledRetainablesNow:Za,retainedByOptionWithDefault:Ya};const{unstable_batchedUpdates:Xa}=jo;var Ja={unstable_batchedUpdates:Xa};const{unstable_batchedUpdates:Qa}=Ja;var es={unstable_batchedUpdates:Qa};const{batchStart:ts}=ge,{unstable_batchedUpdates:ns}=es;let os=ns||(e=>e());const rs=e=>{os(()=>{let t=()=>{};try{t=ts(),e()}finally{t()}})};var tn={batchUpdates:rs};function*as(e){for(const t of e)for(const n of t)yield n}var co=as;const ss=typeof Window>"u"||typeof window>"u";var nn={isSSR:ss};function is(e,t){let n,o;return[(...i)=>{const u=t(...i);return n===u||(n=u,o=e(...i)),o},()=>{n=null}]}var ls={memoizeOneWithArgsHashAndInvalidation:is};const{batchUpdates:Bt}=tn,{initializeNode:cs,peekNodeInfo:us}=Ne,{graph:ds}=Je,{getNextStoreID:fs}=_t,{DEFAULT_VALUE:hs,recoilValues:yn,recoilValuesForKeys:Sn}=_e,{AbstractRecoilValue:vs,getRecoilValueAsLoadable:ps,setRecoilValue:gn,setUnvalidatedRecoilValue:_s}=ge,{updateRetainCount:lt}=Pe,{setInvalidateMemoizedSnapshot:ms}=Xn,{getNextTreeStateVersion:ys,makeEmptyStoreState:Ss}=Hn,{isSSR:gs}=nn,{memoizeOneWithArgsHashAndInvalidation:Rs}=ls;class yt{constructor(t,n){V(this,"_store",void 0),V(this,"_refCount",1),V(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ps(this._store,o))),V(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),V(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const i=this._store.getState().currentTree;return Sn(i.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?yn.values():o.isInitialized===!0?Sn(co([r,a])):Jt(yn.values(),({key:i})=>!r.has(i)&&!a.has(i))}),V(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),us(this._store,this._store.getState().currentTree,o))),V(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new zt(this,Bt);return o(r),r}),V(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new zt(this,Bt);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:fs(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return j(r.get(o));const a=ds();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw M("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)cs(this._store,o,"get"),lt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&ie(),this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){gs||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!F("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){F("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function uo(e,t,n=!1){const o=e.getState(),r=n?ys():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(pt(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function bs(e){const t=new yt(Ss());return e!=null?t.map(e):t}const[Rn,fo]=Rs((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:j(o.previousTree);return new yt(uo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});ms(fo);function ws(e,t="latest"){const n=Rn(e,t);return n.isRetained()?n:(fo(),Rn(e,t))}class zt extends yt{constructor(t,n){super(uo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),V(this,"_batch",void 0),V(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{lt(a,o.key,1),gn(this.getStore_INTERNAL(),o,r)})}),V(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{lt(r,o.key,1),gn(this.getStore_INTERNAL(),o,hs)})}),V(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();Bt(()=>{for(const[a,i]of o.entries())lt(r,a,1),_s(r,new vs(a),i)})}),this._batch=n}}var St={Snapshot:yt,MutableSnapshot:zt,freshSnapshot:bs,cloneSnapshot:ws},Es=St.Snapshot,Ts=St.MutableSnapshot,As=St.freshSnapshot,Ns=St.cloneSnapshot,gt=Object.freeze({__proto__:null,Snapshot:Es,MutableSnapshot:Ts,freshSnapshot:As,cloneSnapshot:Ns});function Ls(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var Cs=Ls;const{useRef:Vs}=Z;function $s(e){const t=Vs(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var bn=$s;const{getNextTreeStateVersion:Ms,makeEmptyStoreState:ho}=Hn,{cleanUpNode:ks,getDownstreamNodes:Ds,initializeNode:Is,setNodeValue:Us,setUnvalidatedAtomValue_DEPRECATED:Ps}=Ne,{graph:xs}=Je,{cloneGraph:Os}=Je,{getNextStoreID:vo}=_t,{createMutableSource:Dt,reactMode:po}=Ht,{applyAtomValueWrites:Bs}=ge,{releaseScheduledRetainablesNow:_o}=Pe,{freshSnapshot:zs}=gt,{useCallback:Fs,useContext:mo,useEffect:Ft,useMemo:Ws,useRef:Ks,useState:Gs}=Z;function ze(){throw M("This component must be used inside a <RecoilRoot> component.")}const yo=Object.freeze({storeID:vo(),getState:ze,replaceState:ze,getGraph:ze,subscribeToTransactions:ze,addTransactionMetadata:ze});let Wt=!1;function wn(e){if(Wt)throw M("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){F("recoil_memory_managament_2020")&&F("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&_o(e);const n=t.currentTree.version,o=Ms();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Os(j(t.graphsByVersion.get(n))))}}const So=Z.createContext({current:yo}),on=()=>mo(So),go=Z.createContext(null);function Hs(){const e=mo(go);return e==null&&Fn(),e}function Ro(e,t,n){const o=Ds(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[i,[u,d]]of a)d(n)}}function js(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[i,u]of a)u(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!po().early||t.suspendedComponentResolvers.size>0)&&(Ro(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function qs(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,js(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):ie("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,F("recoil_memory_managament_2020")&&n==null&&_o(e)}finally{t.commitDepth--}}function Zs({setNotifyBatcherOfChange:e}){const t=on(),[,n]=Gs([]);return e(()=>n({})),Ft(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),Ft(()=>{Ir.enqueueExecution("Batcher",()=>{qs(t.current)})}),null}function Ys(e,t){const n=ho();return t({set:(o,r)=>{const a=n.currentTree,i=Us(e,a,o.key,r),u=new Set(i.keys()),d=a.nonvalidatedAtoms.clone();for(const f of u)d.delete(f);n.currentTree={...a,dirtyAtoms:Cs(a.dirtyAtoms,u),atomValues:Bs(a.atomValues,i),nonvalidatedAtoms:d}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Ps(n.currentTree,a,r)})}}),n}function Xs(e){const t=zs(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let En=0;function Js({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=L=>{const E=r.current.graphsByVersion;if(E.has(L))return j(E.get(L));const $=xs();return E.set(L,$),$},i=(L,E)=>{if(E==null){const{transactionSubscriptions:$}=g.current.getState(),Q=En++;return $.set(Q,L),{release:()=>{$.delete(Q)}}}else{const{nodeTransactionSubscriptions:$}=g.current.getState();$.has(E)||$.set(E,new Map);const Q=En++;return j($.get(E)).set(Q,L),{release:()=>{const te=$.get(E);te&&(te.delete(Q),te.size===0&&$.delete(E))}}}},u=L=>{wn(g.current);for(const E of Object.keys(L))j(g.current.getState().nextTree).transactionMetadata[E]=L[E]},d=L=>{wn(g.current);const E=j(r.current.nextTree);let $;try{Wt=!0,$=L(E)}finally{Wt=!1}$!==E&&(r.current.nextTree=$,po().early&&Ro(g.current,r.current,$),j(f.current)())},f=Ks(null),p=Fs(L=>{f.current=L},[f]),g=bn(()=>n??{storeID:vo(),getState:()=>r.current,replaceState:d,getGraph:a,subscribeToTransactions:i,addTransactionMetadata:u});n!=null&&(g.current=n),r=bn(()=>e!=null?Ys(g.current,e):t!=null?Xs(t):ho());const I=Ws(()=>Dt==null?void 0:Dt(r,()=>r.current.currentTree.version),[r]);return Ft(()=>{const L=g.current;for(const E of new Set(L.getState().knownAtoms))Is(L,E,"get");return()=>{for(const E of L.getState().knownAtoms)ks(L,E)}},[g]),Z.createElement(So.Provider,{value:g},Z.createElement(go.Provider,{value:I},Z.createElement(Zs,{setNotifyBatcherOfChange:p}),o))}function Qs(e){const{override:t,...n}=e,o=on();return t===!1&&o.current!==yo?e.children:Z.createElement(Js,n)}var rn={RecoilRoot:Qs,useStoreRef:on,useRecoilMutableSource:Hs};function ei(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var ti=ei;const{useEffect:ni,useRef:oi}=Z;function ri(e){const t=oi();return ni(()=>{t.current=e}),t.current}var ai=ri;const{useStoreRef:si}=rn,{SUSPENSE_TIMEOUT_MS:ii}=Pe,{updateRetainCount:Fe}=Pe,{RetentionZone:li}=Xt,{useEffect:ci,useRef:ui}=Z,{isSSR:Tn}=nn;function di(e){if(F("recoil_memory_managament_2020"))return fi(e)}function fi(e){const n=(Array.isArray(e)?e:[e]).map(i=>i instanceof li?i:i.key),o=si();ci(()=>{if(!F("recoil_memory_managament_2020"))return;const i=o.current;if(r.current&&!Tn)window.clearTimeout(r.current),r.current=null;else for(const u of n)Fe(i,u,1);return()=>{for(const u of n)Fe(i,u,-1)}},[o,...n]);const r=ui(),a=ai(n);if(!Tn&&(a===void 0||!ti(a,n))){const i=o.current;for(const u of n)Fe(i,u,1);if(a)for(const u of a)Fe(i,u,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const u of n)Fe(i,u,-1)},ii)}}var hi=di;function vi(){return"<component name not available>"}var Rt=vi;const{currentRendererSupportsUseSyncExternalStore:pi,reactMode:et,useMutableSource:_i,useSyncExternalStore:mi}=Ht,{useRecoilMutableSource:yi,useStoreRef:xe}=rn,{isRecoilValue:pc}=Te,{getRecoilValueAsLoadable:bt,setRecoilValue:Si,subscribeToRecoilValue:wt}=ge,{useCallback:pe,useEffect:ut,useMemo:gi,useRef:bo,useState:wo}=Z,{isSSR:Ri}=nn;function bi(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),Ri&&K(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:M(`Invalid value of loadable atom "${t.key}"`)}function wi(e){const t=xe(),n=Rt(),o=pe(()=>{var u;const d=t.current,f=d.getState(),p=et().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return{loadable:bt(d,e,p),key:e.key}},[t,e]),r=pe(u=>{let d;return()=>{var f,p;const g=u();return(f=d)!==null&&f!==void 0&&f.loadable.is(g.loadable)&&((p=d)===null||p===void 0?void 0:p.key)===g.key?d:(d=g,g)}},[]),a=gi(()=>r(o),[o,r]),i=pe(u=>{const d=t.current;return wt(d,e,u,n).release},[t,e,n]);return mi(i,a,a).loadable}function Ei(e){const t=xe(),n=pe(()=>{var f;const p=t.current,g=p.getState(),I=et().early&&(f=g.nextTree)!==null&&f!==void 0?f:g.currentTree;return bt(p,e,I)},[t,e]),o=pe(()=>n(),[n]),r=Rt(),a=pe((f,p)=>{const g=t.current;return wt(g,e,()=>{if(!F("recoil_suppress_rerender_in_callback"))return p();const L=n();d.current.is(L)||p(),d.current=L},r).release},[t,e,r,n]),i=yi();if(i==null)throw M("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const u=_i(i,o,a),d=bo(u);return ut(()=>{d.current=u}),u}function An(e){const t=xe(),n=Rt(),o=pe(()=>{var d;const f=t.current,p=f.getState(),g=et().early&&(d=p.nextTree)!==null&&d!==void 0?d:p.currentTree;return bt(f,e,g)},[t,e]),r=pe(()=>({loadable:o(),key:e.key}),[o,e.key]),a=pe(d=>{const f=r();return d.loadable.is(f.loadable)&&d.key===f.key?d:f},[r]);ut(()=>{const d=wt(t.current,e,f=>{u(a)},n);return u(a),d.release},[n,e,t,a]);const[i,u]=wo(r);return i.key!==e.key?r().loadable:i.loadable}function Ti(e){const t=xe(),[,n]=wo([]),o=Rt(),r=pe(()=>{var u;const d=t.current,f=d.getState(),p=et().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return bt(d,e,p)},[t,e]),a=r(),i=bo(a);return ut(()=>{i.current=a}),ut(()=>{const u=t.current,d=u.getState(),f=wt(u,e,g=>{var I;if(!F("recoil_suppress_rerender_in_callback"))return n([]);const L=r();(I=i.current)!==null&&I!==void 0&&I.is(L)||n(L),i.current=L},o);if(d.nextTree)u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,n([])});else{var p;if(!F("recoil_suppress_rerender_in_callback"))return n([]);const g=r();(p=i.current)!==null&&p!==void 0&&p.is(g)||n(g),i.current=g}return f.release},[o,r,e,t]),a}function Ai(e){return F("recoil_memory_managament_2020")&&hi(e),{TRANSITION_SUPPORT:An,SYNC_EXTERNAL_STORE:pi()?wi:An,MUTABLE_SOURCE:Ei,LEGACY:Ti}[et().mode](e)}function Ni(e){const t=xe(),n=Ai(e);return bi(n,e,t)}function Li(e){const t=xe();return pe(n=>{Si(t.current,e,n)},[t,e])}var Ci={useRecoilValue:Ni,useSetRecoilState:Li};const{batchUpdates:Vi}=tn,{DEFAULT_VALUE:$i,getNode:Mi}=_e,{AbstractRecoilValue:ki,setRecoilValueLoadable:Di}=ge,{cloneSnapshot:_c}=gt,{useCallback:mc,useEffect:yc,useRef:Sc,useState:gc}=Z;function Ii(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Vi(()=>{const i=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const p of f){var u,d;((u=r.atomValues.get(p))===null||u===void 0?void 0:u.contents)!==((d=a.atomValues.get(p))===null||d===void 0?void 0:d.contents)&&Mi(p).shouldRestoreFromSnapshots&&i.add(p)}i.forEach(f=>{Di(e,new ki(f),a.atomValues.has(f)?j(a.atomValues.get(f)):$i)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}var Ui={gotoSnapshot:Ii};const{useMemo:Rc}=Z,{loadableWithValue:Pi}=Ye,{initializeNode:xi}=Ne,{DEFAULT_VALUE:Oi,getNode:Bi}=_e,{copyTreeState:zi,getRecoilValueAsLoadable:Fi,invalidateDownstreams:Wi,writeLoadableToTreeState:Ki}=ge;function Nn(e){return Bi(e.key).nodeType==="atom"}class Gi{constructor(t,n){V(this,"_store",void 0),V(this,"_treeState",void 0),V(this,"_changes",void 0),V(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!Nn(o))throw M("Reading selectors within atomicUpdate is not supported");const r=Fi(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:M(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),V(this,"set",(o,r)=>{if(!Nn(o))throw M("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else xi(this._store,o.key,"set"),this._changes.set(o.key,r)}),V(this,"reset",o=>{this.set(o,Oi)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=zi(this._treeState);for(const[n,o]of this._changes)Ki(t,n,Pi(o));return Wi(this._store,t),t}}function Hi(e){return t=>{e.replaceState(n=>{const o=new Gi(e,n);return t(o),o.newTreeState_INTERNAL()})}}var ji={atomicUpdater:Hi},qi=ji.atomicUpdater,Eo=Object.freeze({__proto__:null,atomicUpdater:qi});function Zi(e,t){if(!e)throw new Error(t)}var Yi=Zi,He=Yi;const{atomicUpdater:Xi}=Eo,{batchUpdates:Ji}=tn,{DEFAULT_VALUE:Qi}=_e,{refreshRecoilValue:el,setRecoilValue:Ln}=ge,{cloneSnapshot:tl}=gt,{gotoSnapshot:nl}=Ui,{useCallback:bc}=Z;class To{}const ol=new To;function rl(e,t,n,o){let r=ol,a;if(Ji(()=>{const u="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw M(u);const d=jn({...o??{},set:(p,g)=>Ln(e,p,g),reset:p=>Ln(e,p,Qi),refresh:p=>el(e,p),gotoSnapshot:p=>nl(e,p),transact_UNSTABLE:p=>Xi(e)(p)},{snapshot:()=>{const p=tl(e);return a=p.retain(),p}}),f=t(d);if(typeof f!="function")throw M(u);r=f(...n)}),r instanceof To&&He(!1),K(r))r=r.finally(()=>{var u;(u=a)===null||u===void 0||u()});else{var i;(i=a)===null||i===void 0||i()}return r}var al={recoilCallback:rl};const{useCallback:wc}=Z,{atomicUpdater:Ec}=Eo,{useMemo:Tc}=Z;class sl{constructor(t){V(this,"value",void 0),this.value=t}}var il={WrappedValue:sl},ll=il.WrappedValue,Ao=Object.freeze({__proto__:null,WrappedValue:ll});class Cn extends Error{}class cl{constructor(t){var n,o,r;V(this,"_name",void 0),V(this,"_numLeafs",void 0),V(this,"_root",void 0),V(this,"_onHit",void 0),V(this,"_onSet",void 0),V(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,i,u,d;let f,p;for(const[Q,te]of t){var g,I,L;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const U=f;if(f=U?U.branches.get(p):w,f=(g=f)!==null&&g!==void 0?g:{type:"branch",nodeKey:Q,parent:U,branches:new Map,branchKey:p},f.type!=="branch"||f.nodeKey!==Q)throw this.invalidCacheError();U==null||U.branches.set(p,f),o==null||(I=o.onNodeVisit)===null||I===void 0||I.call(o,f),p=this._mapNodeValue(te),this._root=(L=this._root)!==null&&L!==void 0?L:f}const E=f?(a=f)===null||a===void 0?void 0:a.branches.get(p):this._root;if(E!=null&&(E.type!=="leaf"||E.branchKey!==p))throw this.invalidCacheError();const $={type:"leaf",value:n,parent:f,branchKey:p};(i=f)===null||i===void 0||i.branches.set(p,$),this._root=(u=this._root)!==null&&u!==void 0?u:$,this._numLeafs++,this._onSet($),o==null||(d=o.onNodeVisit)===null||d===void 0||d.call(o,$)};try{r()}catch(a){if(a instanceof Cn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){throw ie("Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache."+(this._name!=null?` - ${this._name}`:"")),new Cn}}var ul={TreeCache:cl},dl=ul.TreeCache,No=Object.freeze({__proto__:null,TreeCache:dl});class fl{constructor(t){var n;V(this,"_maxSize",void 0),V(this,"_size",void 0),V(this,"_head",void 0),V(this,"_tail",void 0),V(this,"_map",void 0),V(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),i={key:t,right:a,left:null,value:n};a?a.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=j(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var hl={LRUCache:fl},vl=hl.LRUCache,Lo=Object.freeze({__proto__:null,LRUCache:vl});const{LRUCache:pl}=Lo,{TreeCache:_l}=No;function ml({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new pl({maxSize:t}),r=new _l({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const i=o.tail();o.set(a,!0),i&&r.size()>t&&r.delete(i.key)}});return r}var Vn=ml;function ve(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw M("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(K(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>ve(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return ve(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,i]of e)r[typeof a=="string"?a:ve(a,t)]=i;return ve(r,t,n)}return e instanceof Set?ve(Array.from(e).sort((r,a)=>ve(r,t).localeCompare(ve(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?ve(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${ve(r,t)}:${ve(e[r],t,r)}`).join(",")}}`}function yl(e,t={allowFunctions:!1}){return ve(e,t)}var an=yl;const{TreeCache:Sl}=No,ot={equality:"reference",eviction:"keep-all",maxSize:1/0};function gl({equality:e=ot.equality,eviction:t=ot.eviction,maxSize:n=ot.maxSize}=ot,o){const r=Rl(e);return bl(t,n,r,o)}function Rl(e){switch(e){case"reference":return t=>t;case"value":return t=>an(t)}throw M(`Unrecognized equality policy ${e}`)}function bl(e,t,n,o){switch(e){case"keep-all":return new Sl({name:o,mapNodeValue:n});case"lru":return Vn({name:o,maxSize:j(t),mapNodeValue:n});case"most-recent":return Vn({name:o,maxSize:1,mapNodeValue:n})}throw M(`Unrecognized eviction policy ${e}`)}var wl=gl;const{isLoadable:El,loadableWithError:rt,loadableWithPromise:Tl,loadableWithValue:It}=Ye,{WrappedValue:Co}=Ao,{getNodeLoadable:at,peekNodeLoadable:Al,setNodeValue:Nl}=Ne,{saveDepsToStore:Ll}=Je,{DEFAULT_VALUE:Cl,getConfigDeletionHandler:Vl,getNode:$l,registerNode:$n}=_e,{isRecoilValue:Ml}=Te,{markRecoilValueModified:Mn}=ge,{retainedByOptionWithDefault:kl}=Pe,{recoilCallback:Dl}=al;class Vo{}const We=new Vo,Ke=[],st=new Map,Il=(()=>{let e=0;return()=>e++})();function $o(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,i=new Set,u=wl(r??{equality:"reference",eviction:"keep-all"},n),d=kl(e.retainedBy_UNSTABLE),f=new Map;let p=0;function g(){return!F("recoil_memory_managament_2020")||p>0}function I(c){return c.getState().knownSelectors.add(n),p++,()=>{p--}}function L(){return Vl(n)!==void 0&&!g()}function E(c,v,_,C,R){de(v,C,R),$(c,_)}function $(c,v){le(c,v)&&X(c),te(v,!0)}function Q(c,v){le(c,v)&&(j(J(c)).stateVersions.clear(),te(v,!1))}function te(c,v){const _=st.get(c);if(_!=null){for(const C of _)Mn(C,j(t));v&&st.delete(c)}}function w(c,v){let _=st.get(v);_==null&&st.set(v,_=new Set),_.add(c)}function U(c,v,_,C,R,k){return v.then(b=>{if(!g())throw X(c),We;const x=It(b);return E(c,_,R,x,C),b}).catch(b=>{if(!g())throw X(c),We;if(K(b))return Y(c,b,_,C,R,k);const x=rt(b);throw E(c,_,R,x,C),b})}function Y(c,v,_,C,R,k){return v.then(b=>{if(!g())throw X(c),We;k.loadingDepKey!=null&&k.loadingDepPromise===v?_.atomValues.set(k.loadingDepKey,It(b)):c.getState().knownSelectors.forEach(O=>{_.atomValues.delete(O)});const x=q(c,_);if(x&&x.state!=="loading"){if((le(c,R)||J(c)==null)&&$(c,R),x.state==="hasValue")return x.contents;throw x.contents}if(!le(c,R)){const O=ye(c,_);if(O!=null)return O.loadingLoadable.contents}const[W,ee]=G(c,_,R);if(W.state!=="loading"&&E(c,_,R,W,ee),W.state==="hasError")throw W.contents;return W.contents}).catch(b=>{if(b instanceof Vo)throw We;if(!g())throw X(c),We;const x=rt(b);throw E(c,_,R,x,C),b})}function z(c,v,_,C){var R,k,b,x;if(le(c,C)||v.version===((R=c.getState())===null||R===void 0||(k=R.currentTree)===null||k===void 0?void 0:k.version)||v.version===((b=c.getState())===null||b===void 0||(x=b.nextTree)===null||x===void 0?void 0:x.version)){var W,ee,O;Ll(n,_,c,(W=(ee=c.getState())===null||ee===void 0||(O=ee.nextTree)===null||O===void 0?void 0:O.version)!==null&&W!==void 0?W:c.getState().currentTree.version)}for(const ne of _)i.add(ne)}function G(c,v,_){let C=!0,R=!0;const k=()=>{R=!1};let b,x=!1,W;const ee={loadingDepKey:null,loadingDepPromise:null},O=new Map;function ne({key:ce}){const ae=at(c,v,ce);switch(O.set(ce,ae),C||(z(c,v,new Set(O.keys()),_),Q(c,_)),ae.state){case"hasValue":return ae.contents;case"hasError":throw ae.contents;case"loading":throw ee.loadingDepKey=ce,ee.loadingDepPromise=ae.contents,ae.contents}throw M("Invalid Loadable state")}const me=ce=>(...ae)=>{if(R)throw M("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&He(!1),Dl(c,ce,ae,{node:t})};try{b=o({get:ne,getCallback:me}),b=Ml(b)?ne(b):b,El(b)&&(b.state==="hasError"&&(x=!0),b=b.contents),K(b)?b=U(c,b,v,O,_,ee).finally(k):k(),b=b instanceof Co?b.value:b}catch(ce){b=ce,K(b)?b=Y(c,b,v,O,_,ee).finally(k):(x=!0,k())}return x?W=rt(b):K(b)?W=Tl(b):W=It(b),C=!1,Ce(c,_,O),z(c,v,new Set(O.keys()),_),[W,O]}function q(c,v){let _=v.atomValues.get(n);if(_!=null)return _;const C=new Set;try{_=u.get(k=>(typeof k!="string"&&He(!1),at(c,v,k).contents),{onNodeVisit:k=>{k.type==="branch"&&k.nodeKey!==n&&C.add(k.nodeKey)}})}catch(k){throw M(`Problem with cache lookup for selector "${n}": ${k.message}`)}if(_){var R;v.atomValues.set(n,_),z(c,v,C,(R=J(c))===null||R===void 0?void 0:R.executionID)}return _}function re(c,v){const _=q(c,v);if(_!=null)return X(c),_;const C=ye(c,v);if(C!=null){var R;return((R=C.loadingLoadable)===null||R===void 0?void 0:R.state)==="loading"&&w(c,C.executionID),C.loadingLoadable}const k=Il(),[b,x]=G(c,v,k);return b.state==="loading"?(ue(c,k,b,x,v),w(c,k)):(X(c),de(v,b,x)),b}function ye(c,v){const _=co([f.has(c)?[j(f.get(c))]:[],pt(Jt(f,([R])=>R!==c),([,R])=>R)]);function C(R){for(const[k,b]of R)if(!at(c,v,k).is(b))return!0;return!1}for(const R of _){if(R.stateVersions.get(v.version)||!C(R.depValuesDiscoveredSoFarDuringAsyncWork))return R.stateVersions.set(v.version,!0),R;R.stateVersions.set(v.version,!1)}}function J(c){return f.get(c)}function ue(c,v,_,C,R){f.set(c,{depValuesDiscoveredSoFarDuringAsyncWork:C,executionID:v,loadingLoadable:_,stateVersions:new Map([[R.version,!0]])})}function Ce(c,v,_){if(le(c,v)){const C=J(c);C!=null&&(C.depValuesDiscoveredSoFarDuringAsyncWork=_)}}function X(c){f.delete(c)}function le(c,v){var _;return v===((_=J(c))===null||_===void 0?void 0:_.executionID)}function be(c){return Array.from(c.entries()).map(([v,_])=>[v,_.contents])}function de(c,v,_){c.atomValues.set(n,v);try{u.set(be(_),v)}catch(C){throw M(`Problem with setting cache for selector "${n}": ${C.message}`)}}function Se(c){if(Ke.includes(n)){const v=`Recoil selector has circular dependencies: ${Ke.slice(Ke.indexOf(n)).join("  ")}`;return rt(M(v))}Ke.push(n);try{return c()}finally{Ke.pop()}}function Ve(c,v){const _=v.atomValues.get(n);return _??u.get(C=>{var R;return typeof C!="string"&&He(!1),(R=Al(c,v,C))===null||R===void 0?void 0:R.contents})}function $e(c,v){return Se(()=>re(c,v))}function P(c){c.atomValues.delete(n)}function B(c,v){t==null&&He(!1);for(const C of i){var _;const R=$l(C);(_=R.clearCache)===null||_===void 0||_.call(R,c,v)}i.clear(),P(v),u.clear(),Mn(c,t)}return a!=null?t=$n({key:n,nodeType:"selector",peek:Ve,get:$e,set:(v,_,C)=>{let R=!1;const k=new Map;function b({key:O}){if(R)throw M("Recoil: Async selector sets are not currently supported.");const ne=at(v,_,O);if(ne.state==="hasValue")return ne.contents;if(ne.state==="loading"){const me=`Getting value of asynchronous atom or selector "${O}" in a pending state while setting selector "${n}" is not yet supported.`;throw ie(),M(me)}else throw ne.contents}function x(O,ne){if(R){const ae="Recoil: Async selector sets are not currently supported.";throw ie(),M(ae)}const me=typeof ne=="function"?ne(b(O)):ne;Nl(v,_,O.key,me).forEach((ae,tt)=>k.set(tt,ae))}function W(O){x(O,Cl)}const ee=a({set:x,get:b,reset:W},C);if(ee!==void 0)throw K(ee)?M("Recoil: Async selector sets are not currently supported."):M("Recoil: selector set should be a void function.");return R=!0,k},init:I,invalidate:P,clearCache:B,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d}):t=$n({key:n,nodeType:"selector",peek:Ve,get:$e,init:I,invalidate:P,clearCache:B,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}$o.value=e=>new Co(e);var qe=$o;const{isLoadable:Ul,loadableWithError:Ut,loadableWithPromise:Pt,loadableWithValue:ke}=Ye,{WrappedValue:Mo}=Ao,{peekNodeInfo:Pl}=Ne,{DEFAULT_VALUE:we,DefaultValue:Re,getConfigDeletionHandler:ko,registerNode:xl,setConfigDeletionHandler:Ol}=_e,{isRecoilValue:Bl}=Te,{getRecoilValueAsLoadable:zl,markRecoilValueModified:Fl,setRecoilValue:kn,setRecoilValueLoadable:Wl}=ge,{retainedByOptionWithDefault:Kl}=Pe,Ge=e=>e instanceof Mo?e.value:e;function Gl(e){const{key:t,persistence_UNSTABLE:n}=e,o=Kl(e.retainedBy_UNSTABLE);let r=0;function a(w){return Pt(w.then(U=>(i=ke(U),U)).catch(U=>{throw i=Ut(U),U}))}let i=K(e.default)?a(e.default):Ul(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:ke(Ge(e.default));i.contents;let u;const d=new Map;function f(w){return w}function p(w,U){const Y=U.then(z=>{var G,q;return((q=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||q===void 0?void 0:q.contents)===Y&&kn(w,te,z),z}).catch(z=>{var G,q;throw((q=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||q===void 0?void 0:q.contents)===Y&&Wl(w,te,Ut(z)),z});return Y}function g(w,U,Y){var z;r++;const G=()=>{var J;r--,(J=d.get(w))===null||J===void 0||J.forEach(ue=>ue()),d.delete(w)};if(w.getState().knownAtoms.add(t),i.state==="loading"){const J=()=>{var ue;((ue=w.getState().nextTree)!==null&&ue!==void 0?ue:w.getState().currentTree).atomValues.has(t)||Fl(w,te)};i.contents.finally(J)}const q=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(q!=null){let J=function(P){if(le&&P.key===t){const B=X;return B instanceof Re?I(w,U):K(B)?Pt(B.then(c=>c instanceof Re?i.toPromise():c)):ke(B)}return zl(w,P)},ue=function(P){return J(P).toPromise()},Ce=function(P){var B;const c=Pl(w,(B=w.getState().nextTree)!==null&&B!==void 0?B:w.getState().currentTree,P.key);return le&&P.key===t&&!(X instanceof Re)?{...c,isSet:!0,loadable:J(P)}:c},X=we,le=!0,be=!1,de=null;const Se=P=>B=>{if(le){const c=J(te),v=c.state==="hasValue"?c.contents:we;X=typeof B=="function"?B(v):B,K(X)&&(X=X.then(_=>(de={effect:P,value:_},_)))}else{if(K(B))throw M("Setting atoms to async values is not implemented.");typeof B!="function"&&(de={effect:P,value:Ge(B)}),kn(w,te,typeof B=="function"?c=>{const v=Ge(B(c));return de={effect:P,value:v},v}:Ge(B))}},Ve=P=>()=>Se(P)(we),$e=P=>B=>{var c;const{release:v}=w.subscribeToTransactions(_=>{var C;let{currentTree:R,previousTree:k}=_.getState();k||(ie(),k=R);const b=(C=R.atomValues.get(t))!==null&&C!==void 0?C:i;if(b.state==="hasValue"){var x,W,ee,O;const ne=b.contents,me=(x=k.atomValues.get(t))!==null&&x!==void 0?x:i,ce=me.state==="hasValue"?me.contents:we;((W=de)===null||W===void 0?void 0:W.effect)!==P||((ee=de)===null||ee===void 0?void 0:ee.value)!==ne?B(ne,ce,!R.atomValues.has(t)):((O=de)===null||O===void 0?void 0:O.effect)===P&&(de=null)}},t);d.set(w,[...(c=d.get(w))!==null&&c!==void 0?c:[],v])};for(const P of q)try{const B=P({node:te,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:Y,setSelf:Se(P),resetSelf:Ve(P),onSet:$e(P),getPromise:ue,getLoadable:J,getInfo_UNSTABLE:Ce});if(B!=null){var re;d.set(w,[...(re=d.get(w))!==null&&re!==void 0?re:[],B])}}catch(B){X=B,be=!0}if(le=!1,!(X instanceof Re)){var ye;const P=be?Ut(X):K(X)?Pt(p(w,X)):ke(Ge(X));P.contents,U.atomValues.set(t,P),(ye=w.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return G}function I(w,U){var Y,z;return(Y=(z=U.atomValues.get(t))!==null&&z!==void 0?z:u)!==null&&Y!==void 0?Y:i}function L(w,U){if(U.atomValues.has(t))return j(U.atomValues.get(t));if(U.nonvalidatedAtoms.has(t)){if(u!=null)return u;if(n==null)return Fn(),i;const Y=U.nonvalidatedAtoms.get(t),z=n.validator(Y,we);return u=z instanceof Re?i:ke(z),u}else return i}function E(){u=void 0}function $(w,U,Y){if(U.atomValues.has(t)){const z=j(U.atomValues.get(t));if(z.state==="hasValue"&&Y===z.contents)return new Map}else if(!U.nonvalidatedAtoms.has(t)&&Y instanceof Re)return new Map;return u=void 0,new Map().set(t,ke(Y))}function Q(){return ko(t)!==void 0&&r<=0}const te=xl({key:t,nodeType:"atom",peek:I,get:L,set:$,init:g,invalidate:E,shouldDeleteConfigOnRelease:Q,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return te}function sn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return Bl(n)?Hl({...t,default:n}):Gl({...t,default:n})}function Hl(e){const t=sn({...e,default:we,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Re?o:j(e.persistence_UNSTABLE).validator(o,we)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=qe({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof Re?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Ol(n.key,ko(e.key)),n}sn.value=e=>new Mo(e);var jl=sn;class ql{constructor(t){var n;V(this,"_map",void 0),V(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Zl={MapCache:ql},Yl=Zl.MapCache,Xl=Object.freeze({__proto__:null,MapCache:Yl});const{LRUCache:Dn}=Lo,{MapCache:Jl}=Xl,it={equality:"reference",eviction:"none",maxSize:1/0};function Ql({equality:e=it.equality,eviction:t=it.eviction,maxSize:n=it.maxSize}=it){const o=ec(e);return tc(t,n,o)}function ec(e){switch(e){case"reference":return t=>t;case"value":return t=>an(t)}throw M(`Unrecognized equality policy ${e}`)}function tc(e,t,n){switch(e){case"keep-all":return new Jl({mapKey:n});case"lru":return new Dn({mapKey:n,maxSize:j(t)});case"most-recent":return new Dn({mapKey:n,maxSize:1})}throw M(`Unrecognized eviction policy ${e}`)}var nc=Ql;const{setConfigDeletionHandler:oc}=_e;let rc=0;function ac(e){var t,n;const o=nc({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let i;try{i=o.get(r)}catch(I){throw M(`Problem with cache lookup for selector ${e.key}: ${I.message}`)}if(i!=null)return i;const u=`${e.key}__selectorFamily/${(a=an(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${rc++}`,d=I=>e.get(r)(I),f=e.cachePolicy_UNSTABLE,p=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let g;if(e.set!=null){const I=e.set;g=qe({key:u,get:d,set:(E,$)=>I(r)(E,$),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:p})}else g=qe({key:u,get:d,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:p});return o.set(r,g),oc(g.key,()=>{o.delete(r)}),g}}var Le=ac;Le({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});Le({key:"__error",get:e=>()=>{throw M(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});const{loadableWithError:Do,loadableWithPromise:Io,loadableWithValue:Uo}=Ye;function Et(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(i){o[r]=i}return[n,o]}function sc(e){return e!=null&&!K(e)}function Tt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function Kt(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function De(e,t,n){const o=n.map((r,a)=>r==null?Uo(t[a]):K(r)?Io(r):Do(r));return Kt(e,o)}function ic(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}Le({key:"__waitForNone",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return De(e,o,r)},dangerouslyAllowMutability:!0});Le({key:"__waitForAny",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return r.some(a=>!K(a))?De(e,o,r):new Promise(a=>{for(const[i,u]of r.entries())K(u)&&u.then(d=>{o[i]=d,r[i]=void 0,a(De(e,o,r))}).catch(d=>{r[i]=d,a(De(e,o,r))})})},dangerouslyAllowMutability:!0});Le({key:"__waitForAll",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);if(r.every(i=>i==null))return Kt(e,o);const a=r.find(sc);if(a!=null)throw a;return Promise.all(r).then(i=>Kt(e,ic(o,i)))},dangerouslyAllowMutability:!0});Le({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return r.every(a=>!K(a))?De(e,o,r):Promise.all(r.map((a,i)=>K(a)?a.then(u=>{o[i]=u,r[i]=void 0}).catch(u=>{o[i]=void 0,r[i]=u}):null)).then(()=>De(e,o,r))},dangerouslyAllowMutability:!0});Le({key:"__noWait",get:e=>({get:t})=>{try{return qe.value(Uo(t(e)))}catch(n){return qe.value(K(n)?Io(n):Do(n))}},dangerouslyAllowMutability:!0});const{RecoilLoadable:Ac}=Ye,{RecoilRoot:lc}=rn,{isRecoilValue:Nc}=Te,{freshSnapshot:Lc}=gt,{useRecoilValue:cc,useSetRecoilState:uc}=Ci;var At={RecoilRoot:lc,atom:jl,useRecoilValue:cc,useSetRecoilState:uc},Cc=At.RecoilRoot,Vc=At.atom,$c=At.useRecoilValue,Mc=At.useSetRecoilState;export{Vc as R,Mc as a,Cc as b,$c as c};
