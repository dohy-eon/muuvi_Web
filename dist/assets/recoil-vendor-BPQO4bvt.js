import{R as Z,r as Zo}from"./react-vendor-BCvJ4SZV.js";var In={};function Yo(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Xo=Yo,M=Xo;function Jo(e){return!!e&&typeof e.then=="function"}var K=Jo;function Qo(e,t){if(e!=null)return e;throw M(t??"Got unexpected null or undefined")}var j=Qo;function V(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class ft{getValue(){throw M("BaseLoadable")}toPromise(){throw M("BaseLoadable")}valueMaybe(){throw M("BaseLoadable")}valueOrThrow(){throw M(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw M("BaseLoadable")}promiseOrThrow(){throw M(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw M("BaseLoadable")}errorOrThrow(){throw M(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw M("BaseLoadable")}}class er extends ft{constructor(t){super(),V(this,"state","hasValue"),V(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return K(n)?Ee(n):Ie(n)?n:Ze(n)}catch(n){return K(n)?Ee(n.next(()=>this.map(t))):ht(n)}}}class tr extends ft{constructor(t){super(),V(this,"state","hasError"),V(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Un extends ft{constructor(t){super(),V(this,"state","loading"),V(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ee(this.contents.then(n=>{const o=t(n);if(Ie(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(K(n))return n.then(()=>this.map(t).contents);throw n}))}}function Ze(e){return Object.freeze(new er(e))}function ht(e){return Object.freeze(new tr(e))}function Ee(e){return Object.freeze(new Un(e))}function Pn(){return Object.freeze(new Un(new Promise(()=>{})))}function nr(e){return e.every(t=>t.state==="hasValue")?Ze(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?ht(j(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ee(Promise.all(e.map(t=>t.contents)))}function xn(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Ie(r)?r:K(r)?Ee(r):Ze(r)),o=nr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,i,u)=>({...a,[i]:r[u]}),{}))}function Ie(e){return e instanceof ft}const or={of:e=>K(e)?Ee(e):Ie(e)?e:Ze(e),error:e=>ht(e),loading:()=>Pn(),all:xn,isLoadable:Ie};var Ae={loadableWithValue:Ze,loadableWithError:ht,loadableWithPromise:Ee,loadableLoading:Pn,loadableAll:xn,isLoadable:Ie,RecoilLoadable:or},rr=Ae.loadableWithValue,ar=Ae.loadableWithError,sr=Ae.loadableWithPromise,ir=Ae.loadableLoading,lr=Ae.loadableAll,cr=Ae.isLoadable,ur=Ae.RecoilLoadable,Ye=Object.freeze({__proto__:null,loadableWithValue:rr,loadableWithError:ar,loadableWithPromise:sr,loadableLoading:ir,loadableAll:lr,isLoadable:cr,RecoilLoadable:ur});const xt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function dr(e,t){var n,o;const r=(n=In[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw M(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function fr(e,t){var n;const o=(n=In[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function hr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(dr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{xt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),fr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{xt.RECOIL_GKS_ENABLED.add(n)})}))}hr();var Xe=xt;function vt(e){return Xe.RECOIL_GKS_ENABLED.has(e)}vt.setPass=e=>{Xe.RECOIL_GKS_ENABLED.add(e)};vt.setFail=e=>{Xe.RECOIL_GKS_ENABLED.delete(e)};vt.clear=()=>{Xe.RECOIL_GKS_ENABLED.clear()};var F=vt;function vr(e,t,{error:n}={}){return null}var pr=vr,ie=pr,Vt,$t,Mt;const _r=(Vt=Z.createMutableSource)!==null&&Vt!==void 0?Vt:Z.unstable_createMutableSource,On=($t=Z.useMutableSource)!==null&&$t!==void 0?$t:Z.unstable_useMutableSource,Gt=(Mt=Z.useSyncExternalStore)!==null&&Mt!==void 0?Mt:Z.unstable_useSyncExternalStore;let fn=!1;function mr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,r=((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null;return Gt&&!r&&!fn&&(fn=!0,ie()),r}function yr(){return F("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:F("recoil_sync_external_store")&&Gt!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:F("recoil_mutable_source")&&On!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?F("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:F("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}var Ht={createMutableSource:_r,useMutableSource:On,useSyncExternalStore:Gt,currentRendererSupportsUseSyncExternalStore:mr,reactMode:yr};class jt{constructor(t){V(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class Bn extends jt{}class zn extends jt{}function Sr(e){return e instanceof Bn||e instanceof zn}var pt={AbstractRecoilValue:jt,RecoilState:Bn,RecoilValueReadOnly:zn,isRecoilValue:Sr},gr=pt.AbstractRecoilValue,Rr=pt.RecoilState,br=pt.RecoilValueReadOnly,wr=pt.isRecoilValue,Te=Object.freeze({__proto__:null,AbstractRecoilValue:gr,RecoilState:Rr,RecoilValueReadOnly:br,isRecoilValue:wr});function Er(e,...t){}var Tr=Er,Fn=Tr;function Ar(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var _t=Ar;class Wn{}const Nr=new Wn,Ue=new Map,qt=new Map;function Lr(e){return _t(e,t=>j(qt.get(t)))}function Cr(e){if(Ue.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function Vr(e){Xe.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&Cr(e.key),Ue.set(e.key,e);const t=e.set==null?new Te.RecoilValueReadOnly(e.key):new Te.RecoilState(e.key);return qt.set(e.key,t),t}class $r extends Error{}function Mr(e){const t=Ue.get(e);if(t==null)throw new $r(`Missing definition for RecoilValue: "${e}""`);return t}function kr(e){return Ue.get(e)}const ut=new Map;function Dr(e){var t;if(!F("recoil_memory_managament_2020"))return;const n=Ue.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ue.delete(e),(o=Kn(e))===null||o===void 0||o(),ut.delete(e)}}function Ir(e,t){F("recoil_memory_managament_2020")&&(t===void 0?ut.delete(e):ut.set(e,t))}function Kn(e){return ut.get(e)}var _e={recoilValues:qt,registerNode:Vr,getNode:Mr,getNodeMaybe:kr,deleteNodeConfigIfPossible:Dr,setConfigDeletionHandler:Ir,getConfigDeletionHandler:Kn,recoilValuesForKeys:Lr,DefaultValue:Wn,DEFAULT_VALUE:Nr};function Ur(e,t){t()}var Pr={enqueueExecution:Ur};function xr(e,t){return t={exports:{}},e(t,t.exports),t.exports}var Or=xr(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(l){return typeof l}:function(l){return l&&typeof Symbol=="function"&&l.constructor===Symbol&&l!==Symbol.prototype?"symbol":typeof l},n={},o=5,r=Math.pow(2,o),a=r-1,i=r/2,u=r/4,d={},f=function(s){return function(){return s}},p=n.hash=function(l){var s=typeof l>"u"?"undefined":t(l);if(s==="number")return l;s!=="string"&&(l+="");for(var h=0,m=0,y=l.length;m<y;++m){var S=l.charCodeAt(m);h=(h<<5)-h+S|0}return h},g=function(s){return s-=s>>1&1431655765,s=(s&858993459)+(s>>2&858993459),s=s+(s>>4)&252645135,s+=s>>8,s+=s>>16,s&127},I=function(s,h){return h>>>s&a},L=function(s){return 1<<s},E=function(s,h){return g(s&h-1)},$=function(s,h,m,y){var S=y;if(!s){var N=y.length;S=new Array(N);for(var T=0;T<N;++T)S[T]=y[T]}return S[h]=m,S},Q=function(s,h,m){var y=m.length-1,S=0,N=0,T=m;if(s)S=N=h;else for(T=new Array(y);S<h;)T[N++]=m[S++];for(++S;S<=y;)T[N++]=m[S++];return s&&(T.length=y),T},te=function(s,h,m,y){var S=y.length;if(s){for(var N=S;N>=h;)y[N--]=y[N];return y[h]=m,y}for(var T=0,A=0,D=new Array(S+1);T<h;)D[A++]=y[T++];for(D[h]=m;T<S;)D[++A]=y[T++];return D},w=1,U=2,Y=3,z=4,G={__hamt_isEmpty:!0},q=function(s){return s===G||s&&s.__hamt_isEmpty},re=function(s,h,m,y){return{type:w,edit:s,hash:h,key:m,value:y,_modify:Ve}},ye=function(s,h,m){return{type:U,edit:s,hash:h,children:m,_modify:$e}},J=function(s,h,m){return{type:Y,edit:s,mask:h,children:m,_modify:P}},ue=function(s,h,m){return{type:z,edit:s,size:h,children:m,_modify:B}},Ce=function(s){return s===G||s.type===w||s.type===U},X=function(s,h,m,y,S){for(var N=[],T=y,A=0,D=0;T;++D)T&1&&(N[D]=S[A++]),T>>>=1;return N[h]=m,ue(s,A+1,N)},le=function(s,h,m,y){for(var S=new Array(h-1),N=0,T=0,A=0,D=y.length;A<D;++A)if(A!==m){var H=y[A];H&&!q(H)&&(S[N++]=H,T|=1<<A)}return J(s,T,S)},be=function l(s,h,m,y,S,N){if(m===S)return ye(s,m,[N,y]);var T=I(h,m),A=I(h,S);return J(s,L(T)|L(A),T===A?[l(s,h+o,m,y,S,N)]:T<A?[y,N]:[N,y])},de=function(s,h,m,y,S,N,T,A){for(var D=S.length,H=0;H<D;++H){var se=S[H];if(m(T,se.key)){var oe=se.value,fe=N(oe);return fe===oe?S:fe===d?(--A.value,Q(s,H,S)):$(s,H,re(h,y,T,fe),S)}}var he=N();return he===d?S:(++A.value,$(s,D,re(h,y,T,he),S))},Se=function(s,h){return s===h.edit},Ve=function(s,h,m,y,S,N,T){if(h(N,this.key)){var A=y(this.value);return A===this.value?this:A===d?(--T.value,G):Se(s,this)?(this.value=A,this):re(s,S,N,A)}var D=y();return D===d?this:(++T.value,be(s,m,this.hash,this,S,re(s,S,N,D)))},$e=function(s,h,m,y,S,N,T){if(S===this.hash){var A=Se(s,this),D=de(A,s,h,this.hash,this.children,y,N,T);return D===this.children?this:D.length>1?ye(s,this.hash,D):D[0]}var H=y();return H===d?this:(++T.value,be(s,m,this.hash,this,S,re(s,S,N,H)))},P=function(s,h,m,y,S,N,T){var A=this.mask,D=this.children,H=I(m,S),se=L(H),oe=E(A,se),fe=A&se,he=fe?D[oe]:G,Me=he._modify(s,h,m+o,y,S,N,T);if(he===Me)return this;var ot=Se(s,this),Oe=A,Be=void 0;if(fe&&q(Me)){if(Oe&=~se,!Oe)return G;if(D.length<=2&&Ce(D[oe^1]))return D[oe^1];Be=Q(ot,oe,D)}else if(!fe&&!q(Me)){if(D.length>=i)return X(s,H,Me,A,D);Oe|=se,Be=te(ot,oe,Me,D)}else Be=$(ot,oe,Me,D);return ot?(this.mask=Oe,this.children=Be,this):J(s,Oe,Be)},B=function(s,h,m,y,S,N,T){var A=this.size,D=this.children,H=I(m,S),se=D[H],oe=(se||G)._modify(s,h,m+o,y,S,N,T);if(se===oe)return this;var fe=Se(s,this),he=void 0;if(q(se)&&!q(oe))++A,he=$(fe,H,oe,D);else if(!q(se)&&q(oe)){if(--A,A<=u)return le(s,A,H,D);he=$(fe,H,G,D)}else he=$(fe,H,oe,D);return fe?(this.size=A,this.children=he,this):ue(s,A,he)};G._modify=function(l,s,h,m,y,S,N){var T=m();return T===d?G:(++N.value,re(l,y,S,T))};function c(l,s,h,m,y){this._editable=l,this._edit=s,this._config=h,this._root=m,this._size=y}c.prototype.setTree=function(l,s){return this._editable?(this._root=l,this._size=s,this):l===this._root?this:new c(this._editable,this._edit,this._config,l,s)};var v=n.tryGetHash=function(l,s,h,m){for(var y=m._root,S=0,N=m._config.keyEq;;)switch(y.type){case w:return N(h,y.key)?y.value:l;case U:{if(s===y.hash)for(var T=y.children,A=0,D=T.length;A<D;++A){var H=T[A];if(N(h,H.key))return H.value}return l}case Y:{var se=I(S,s),oe=L(se);if(y.mask&oe){y=y.children[E(y.mask,oe)],S+=o;break}return l}case z:{if(y=y.children[I(S,s)],y){S+=o;break}return l}default:return l}};c.prototype.tryGetHash=function(l,s,h){return v(l,s,h,this)};var _=n.tryGet=function(l,s,h){return v(l,h._config.hash(s),s,h)};c.prototype.tryGet=function(l,s){return _(l,s,this)};var C=n.getHash=function(l,s,h){return v(void 0,l,s,h)};c.prototype.getHash=function(l,s){return C(l,s,this)},n.get=function(l,s){return v(void 0,s._config.hash(l),l,s)},c.prototype.get=function(l,s){return _(s,l,this)};var R=n.has=function(l,s,h){return v(d,l,s,h)!==d};c.prototype.hasHash=function(l,s){return R(l,s,this)};var k=n.has=function(l,s){return R(s._config.hash(l),l,s)};c.prototype.has=function(l){return k(l,this)};var b=function(s,h){return s===h};n.make=function(l){return new c(0,0,{keyEq:l&&l.keyEq||b,hash:l&&l.hash||p},G,0)},n.empty=n.make();var x=n.isEmpty=function(l){return l&&!!q(l._root)};c.prototype.isEmpty=function(){return x(this)};var W=n.modifyHash=function(l,s,h,m){var y={value:m._size},S=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,l,s,h,y);return m.setTree(S,y.value)};c.prototype.modifyHash=function(l,s,h){return W(h,l,s,this)};var ee=n.modify=function(l,s,h){return W(l,h._config.hash(s),s,h)};c.prototype.modify=function(l,s){return ee(s,l,this)};var O=n.setHash=function(l,s,h,m){return W(f(h),l,s,m)};c.prototype.setHash=function(l,s,h){return O(l,s,h,this)};var ne=n.set=function(l,s,h){return O(h._config.hash(l),l,s,h)};c.prototype.set=function(l,s){return ne(l,s,this)};var me=f(d),ce=n.removeHash=function(l,s,h){return W(me,l,s,h)};c.prototype.removeHash=c.prototype.deleteHash=function(l,s){return ce(l,s,this)};var ae=n.remove=function(l,s){return ce(s._config.hash(l),l,s)};c.prototype.remove=c.prototype.delete=function(l){return ae(l,this)};var nt=n.beginMutation=function(l){return new c(l._editable+1,l._edit+1,l._config,l._root,l._size)};c.prototype.beginMutation=function(){return nt(this)};var ln=n.endMutation=function(l){return l._editable=l._editable&&l._editable-1,l};c.prototype.endMutation=function(){return ln(this)};var Oo=n.mutate=function(l,s){var h=nt(s);return l(h),ln(h)};c.prototype.mutate=function(l){return Oo(l,this)};var Nt=function(s){return s&&cn(s[0],s[1],s[2],s[3],s[4])},cn=function(s,h,m,y,S){for(;m<s;){var N=h[m++];if(N&&!q(N))return un(N,y,[s,h,m,y,S])}return Nt(S)},un=function(s,h,m){switch(s.type){case w:return{value:h(s),rest:m};case U:case z:case Y:var y=s.children;return cn(y.length,y,0,h,m);default:return Nt(m)}},Bo={done:!0};function Lt(l){this.v=l}Lt.prototype.next=function(){if(!this.v)return Bo;var l=this.v;return this.v=Nt(l.rest),l},Lt.prototype[Symbol.iterator]=function(){return this};var Ct=function(s,h){return new Lt(un(s._root,h))},zo=function(s){return[s.key,s.value]},Fo=n.entries=function(l){return Ct(l,zo)};c.prototype.entries=c.prototype[Symbol.iterator]=function(){return Fo(this)};var Wo=function(s){return s.key},Ko=n.keys=function(l){return Ct(l,Wo)};c.prototype.keys=function(){return Ko(this)};var Go=function(s){return s.value},Ho=n.values=c.prototype.values=function(l){return Ct(l,Go)};c.prototype.values=function(){return Ho(this)};var dn=n.fold=function(l,s,h){var m=h._root;if(m.type===w)return l(s,m.value,m.key);for(var y=[m.children],S=void 0;S=y.pop();)for(var N=0,T=S.length;N<T;){var A=S[N++];A&&A.type&&(A.type===w?s=l(s,A.value,A.key):y.push(A.children))}return s};c.prototype.fold=function(l,s){return dn(l,s,this)};var jo=n.forEach=function(l,s){return dn(function(h,m,y){return l(m,y,s)},null,s)};c.prototype.forEach=function(l){return jo(l,this)};var qo=n.count=function(l){return l._size};c.prototype.count=function(){return qo(this)},Object.defineProperty(c.prototype,"size",{get:c.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class Br{constructor(t){V(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return Yt(this)}toMap(){return new Map(this._map)}}class Zt{constructor(t){if(V(this,"_hamt",Or.empty.beginMutation()),t instanceof Zt){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return Yt(this)}toMap(){return new Map(this._hamt)}}function Yt(e){return F("recoil_hamt_2020")?new Zt(e):new Br(e)}var zr={persistentMap:Yt},Fr=zr.persistentMap,Wr=Object.freeze({__proto__:null,persistentMap:Fr});function Kr(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var hn=Kr;function Gr(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var vn=Gr;function Hr(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function jr(e){return{nodeDeps:vn(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:vn(e.nodeToNodeSubscriptions,t=>new Set(t))}}function kt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,i=r.get(e);if(i&&o&&i!==o.nodeDeps.get(e))return;r.set(e,t);const u=i==null?t:hn(t,i);for(const d of u)a.has(d)||a.set(d,new Set),j(a.get(d)).add(e);if(i){const d=hn(i,t);for(const f of d){if(!a.has(f))return;const p=j(a.get(f));p.delete(e),p.size===0&&a.delete(f)}}}function qr(e,t,n,o){var r,a,i,u;const d=n.getState();o===d.currentTree.version||o===((r=d.nextTree)===null||r===void 0?void 0:r.version)||o===((a=d.previousTree)===null||a===void 0?void 0:a.version)||ie();const f=n.getGraph(o);if(kt(e,t,f),o===((i=d.previousTree)===null||i===void 0?void 0:i.version)){const g=n.getGraph(d.currentTree.version);kt(e,t,g,f)}if(o===((u=d.previousTree)===null||u===void 0?void 0:u.version)||o===d.currentTree.version){var p;const g=(p=d.nextTree)===null||p===void 0?void 0:p.version;if(g!==void 0){const I=n.getGraph(g);kt(e,t,I,f)}}}var Je={cloneGraph:jr,graph:Hr,saveDepsToStore:qr};let Zr=0;const Yr=()=>Zr++;let Xr=0;const Jr=()=>Xr++;let Qr=0;const ea=()=>Qr++;var mt={getNextTreeStateVersion:Yr,getNextStoreID:Jr,getNextComponentID:ea};const{persistentMap:pn}=Wr,{graph:ta}=Je,{getNextTreeStateVersion:Gn}=mt;function na(){const e=Gn();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:pn(),nonvalidatedAtoms:pn()}}function oa(){const e=na();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,ta()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var Hn={makeEmptyStoreState:oa,getNextTreeStateVersion:Gn};class ra{}var Xt={RetentionZone:ra};function aa(e,t){const n=new Set(e);return n.add(t),n}var sa={setByAddingToSet:aa};function*ia(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var Jt=ia;function la(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var jn=la;const{getNode:Qe,getNodeMaybe:ca,recoilValuesForKeys:_n}=_e,{RetentionZone:mn}=Xt,{setByAddingToSet:ua}=sa,da=Object.freeze(new Set);class fa extends Error{}function ha(e,t,n){if(!F("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let i=o.get(a);i||o.set(a,i=new Set),i.add(t)}if(n instanceof mn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!F("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function i(u){const d=a.nodesRetainedByZone.get(u);d==null||d.delete(t),d&&d.size===0&&a.nodesRetainedByZone.delete(u)}if(n instanceof mn)i(n);else if(Array.isArray(n))for(const u of n)i(u)}}function Qt(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Qe(n),i=ha(e,n,a.retainedBy),u=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{u(),i()})}function va(e,t,n){Qt(e,e.getState().currentTree,t,n)}function pa(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function _a(e,t,n){return Qt(e,t,n,"get"),Qe(n).get(e,t)}function qn(e,t,n){return Qe(n).peek(e,t)}function ma(e,t,n){var o;const r=ca(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:ua(e.dirtyAtoms,t)}}function ya(e,t,n,o){const r=Qe(n);if(r.set==null)throw new fa(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Qt(e,t,n,"set"),a(e,t,o)}function Sa(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=Qe(n).nodeType;return jn({type:a},{loadable:()=>qn(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var i;return _n((i=r.nodeDeps.get(n))!==null&&i!==void 0?i:[])},subscribers:()=>{var i,u;return{nodes:_n(Jt(Zn(e,t,new Set([n])),d=>d!==n)),components:_t((i=(u=o.nodeToComponentSubscriptions.get(n))===null||u===void 0?void 0:u.values())!==null&&i!==void 0?i:[],([d])=>({name:d}))}}})}function Zn(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let u=r.pop();u;u=r.pop()){var i;o.add(u);const d=(i=a.nodeToNodeSubscriptions.get(u))!==null&&i!==void 0?i:da;for(const f of d)o.has(f)||r.push(f)}return o}var Ne={getNodeLoadable:_a,peekNodeLoadable:qn,setNodeValue:ya,initializeNode:va,cleanUpNode:pa,setUnvalidatedAtomValue_DEPRECATED:ma,peekNodeInfo:Sa,getDownstreamNodes:Zn};let Yn=null;function ga(e){Yn=e}function Ra(){var e;(e=Yn)===null||e===void 0||e()}var Xn={setInvalidateMemoizedSnapshot:ga,invalidateMemoizedSnapshot:Ra};const{getDownstreamNodes:ba,getNodeLoadable:Jn,setNodeValue:wa}=Ne,{getNextComponentID:Ea}=mt,{getNode:Ta,getNodeMaybe:Qn}=_e,{DefaultValue:en}=_e,{reactMode:Aa}=Ht,{AbstractRecoilValue:Na,RecoilState:vc,RecoilValueReadOnly:pc,isRecoilValue:_c}=Te,{invalidateMemoizedSnapshot:La}=Xn;function Ca(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version)||ie();const i=Jn(e,n,t);return i.state==="loading"&&i.contents.catch(()=>{}),i}function Va(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof en?n.delete(r):n.set(r,o)}),n}function $a(e,t,{key:n},o){if(typeof o=="function"){const r=Jn(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw ie(),M(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Ma(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,i=$a(e,t,r,a),u=wa(e,t,r.key,i);for(const[d,f]of u.entries())Ot(t,d,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Ot(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,i=Qn(r);i==null||(o=i.invalidate)===null||o===void 0||o.call(i,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else ie(`Unknown action ${n.type}`)}function Ot(e,t,n){n.state==="hasValue"&&n.contents instanceof en?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function eo(e,t){e.replaceState(n=>{const o=to(n);for(const r of t)Ma(e,o,r);return no(e,o),La(),o})}function yt(e,t){if(je.length){const n=je[je.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else eo(e,[t])}const je=[];function ka(){const e=new Map;return je.push(e),()=>{for(const[n,o]of e)eo(n,o);je.pop()!==e&&ie()}}function to(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function no(e,t){const n=ba(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=Qn(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function oo(e,t,n){yt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Da(e,t,n){if(n instanceof en)return oo(e,t,n);yt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function Ia(e,t){yt(e,{type:"markModified",recoilValue:t})}function Ua(e,t,n){yt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Pa(e,{key:t},n,o=null){const r=Ea(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),j(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const i=Aa();if(i.early&&(i.mode==="LEGACY"||i.mode==="MUTABLE_SOURCE")){const u=e.getState().nextTree;u&&u.dirtyAtoms.has(t)&&n(u)}return{release:()=>{const u=e.getState(),d=u.nodeToComponentSubscriptions.get(t);if(d===void 0||!d.has(r)){ie();return}d.delete(r),d.size===0&&u.nodeToComponentSubscriptions.delete(t)}}}function xa(e,t){var n;const{currentTree:o}=e.getState(),r=Ta(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var ge={AbstractRecoilValue:Na,getRecoilValueAsLoadable:Ca,setRecoilValue:oo,setRecoilValueLoadable:Da,markRecoilValueModified:Ia,setUnvalidatedRecoilValue:Ua,subscribeToRecoilValue:Pa,applyAtomValueWrites:Va,batchStart:ka,writeLoadableToTreeState:Ot,invalidateDownstreams:no,copyTreeState:to,refreshRecoilValue:xa};function Oa(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Ba=Oa;const{cleanUpNode:za}=Ne,{deleteNodeConfigIfPossible:Fa,getNode:ro}=_e,{RetentionZone:ao}=Xt,Wa=12e4,so=new Set;function io(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree){ie();return}const r=new Set;for(const i of t)if(i instanceof ao)for(const u of ja(n,i))r.add(u);else r.add(i);const a=Ka(e,r);for(const i of a)Ha(e,o,i)}function Ka(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return u(t),a;function u(d){const f=new Set,p=Ga(e,o,d,a,i);for(const E of p){var g;if(ro(E).retainedBy==="recoilRoot"){i.add(E);continue}if(((g=n.retention.referenceCounts.get(E))!==null&&g!==void 0?g:0)>0){i.add(E);continue}if(lo(E).some(Q=>n.retention.referenceCounts.get(Q))){i.add(E);continue}const $=r.nodeToNodeSubscriptions.get(E);if($&&Ba($,Q=>i.has(Q))){i.add(E);continue}a.add(E),f.add(E)}const I=new Set;for(const E of f)for(const $ of(L=r.nodeDeps.get(E))!==null&&L!==void 0?L:so){var L;a.has($)||I.add($)}I.size&&u(I)}}function Ga(e,t,n,o,r){const a=e.getGraph(t.version),i=[],u=new Set;for(;n.size>0;)d(j(n.values().next().value));return i;function d(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(u.has(f))return;const p=a.nodeToNodeSubscriptions.get(f);if(p)for(const g of p)d(g);u.add(f),n.delete(f),i.push(f)}}function Ha(e,t,n){if(!F("recoil_memory_managament_2020"))return;za(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=lo(n);for(const d of r){var a;(a=o.retention.nodesRetainedByZone.get(d))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const d=i.nodeDeps.get(n);if(d!==void 0){i.nodeDeps.delete(n);for(const f of d){var u;(u=i.nodeToNodeSubscriptions.get(f))===null||u===void 0||u.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}Fa(n)}function ja(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:so}function lo(e){const t=ro(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof ao?[t]:t}function qa(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):io(e,new Set([t]))}function Za(e,t,n){var o;if(!F("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Ya(e,t):r.set(t,a)}function Ya(e,t){if(!F("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),qa(e,t)}function Xa(e){if(!F("recoil_memory_managament_2020"))return;const t=e.getState();io(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Ja(e){return e===void 0?"recoilRoot":e}var Pe={SUSPENSE_TIMEOUT_MS:Wa,updateRetainCount:Za,releaseScheduledRetainablesNow:Xa,retainedByOptionWithDefault:Ja};const{unstable_batchedUpdates:Qa}=Zo;var es={unstable_batchedUpdates:Qa};const{unstable_batchedUpdates:ts}=es;var ns={unstable_batchedUpdates:ts};const{batchStart:os}=ge,{unstable_batchedUpdates:rs}=ns;let as=rs||(e=>e());const ss=e=>{as(()=>{let t=()=>{};try{t=os(),e()}finally{t()}})};var tn={batchUpdates:ss};function*is(e){for(const t of e)for(const n of t)yield n}var co=is;const ls=typeof Window>"u"||typeof window>"u";var nn={isSSR:ls};function cs(e,t){let n,o;return[(...i)=>{const u=t(...i);return n===u||(n=u,o=e(...i)),o},()=>{n=null}]}var us={memoizeOneWithArgsHashAndInvalidation:cs};const{batchUpdates:Bt}=tn,{initializeNode:ds,peekNodeInfo:fs}=Ne,{graph:hs}=Je,{getNextStoreID:vs}=mt,{DEFAULT_VALUE:ps,recoilValues:yn,recoilValuesForKeys:Sn}=_e,{AbstractRecoilValue:_s,getRecoilValueAsLoadable:ms,setRecoilValue:gn,setUnvalidatedRecoilValue:ys}=ge,{updateRetainCount:ct}=Pe,{setInvalidateMemoizedSnapshot:Ss}=Xn,{getNextTreeStateVersion:gs,makeEmptyStoreState:Rs}=Hn,{isSSR:bs}=nn,{memoizeOneWithArgsHashAndInvalidation:ws}=us;class St{constructor(t,n){V(this,"_store",void 0),V(this,"_refCount",1),V(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ms(this._store,o))),V(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),V(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const i=this._store.getState().currentTree;return Sn(i.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?yn.values():o.isInitialized===!0?Sn(co([r,a])):Jt(yn.values(),({key:i})=>!r.has(i)&&!a.has(i))}),V(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),fs(this._store,this._store.getState().currentTree,o))),V(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new zt(this,Bt);return o(r),r}),V(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new zt(this,Bt);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:vs(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return j(r.get(o));const a=hs();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw M("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)ds(this._store,o,"get"),ct(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&ie(),this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){bs||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!F("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){F("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function uo(e,t,n=!1){const o=e.getState(),r=n?gs():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(_t(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function Es(e){const t=new St(Rs());return e!=null?t.map(e):t}const[Rn,fo]=ws((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:j(o.previousTree);return new St(uo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});Ss(fo);function Ts(e,t="latest"){const n=Rn(e,t);return n.isRetained()?n:(fo(),Rn(e,t))}class zt extends St{constructor(t,n){super(uo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),V(this,"_batch",void 0),V(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{ct(a,o.key,1),gn(this.getStore_INTERNAL(),o,r)})}),V(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{ct(r,o.key,1),gn(this.getStore_INTERNAL(),o,ps)})}),V(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();Bt(()=>{for(const[a,i]of o.entries())ct(r,a,1),ys(r,new _s(a),i)})}),this._batch=n}}var gt={Snapshot:St,MutableSnapshot:zt,freshSnapshot:Es,cloneSnapshot:Ts},As=gt.Snapshot,Ns=gt.MutableSnapshot,Ls=gt.freshSnapshot,Cs=gt.cloneSnapshot,Rt=Object.freeze({__proto__:null,Snapshot:As,MutableSnapshot:Ns,freshSnapshot:Ls,cloneSnapshot:Cs});function Vs(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var $s=Vs;const{useRef:Ms}=Z;function ks(e){const t=Ms(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var bn=ks;const{getNextTreeStateVersion:Ds,makeEmptyStoreState:ho}=Hn,{cleanUpNode:Is,getDownstreamNodes:Us,initializeNode:Ps,setNodeValue:xs,setUnvalidatedAtomValue_DEPRECATED:Os}=Ne,{graph:Bs}=Je,{cloneGraph:zs}=Je,{getNextStoreID:vo}=mt,{createMutableSource:Dt,reactMode:po}=Ht,{applyAtomValueWrites:Fs}=ge,{releaseScheduledRetainablesNow:_o}=Pe,{freshSnapshot:Ws}=Rt,{useCallback:Ks,useContext:mo,useEffect:Ft,useMemo:Gs,useRef:Hs,useState:js}=Z;function ze(){throw M("This component must be used inside a <RecoilRoot> component.")}const yo=Object.freeze({storeID:vo(),getState:ze,replaceState:ze,getGraph:ze,subscribeToTransactions:ze,addTransactionMetadata:ze});let Wt=!1;function wn(e){if(Wt)throw M("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){F("recoil_memory_managament_2020")&&F("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&_o(e);const n=t.currentTree.version,o=Ds();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,zs(j(t.graphsByVersion.get(n))))}}const So=Z.createContext({current:yo}),on=()=>mo(So),go=Z.createContext(null);function qs(){const e=mo(go);return e==null&&Fn(),e}function Ro(e,t,n){const o=Us(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[i,[u,d]]of a)d(n)}}function Zs(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[i,u]of a)u(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!po().early||t.suspendedComponentResolvers.size>0)&&(Ro(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Ys(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Zs(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):ie("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,F("recoil_memory_managament_2020")&&n==null&&_o(e)}finally{t.commitDepth--}}function Xs({setNotifyBatcherOfChange:e}){const t=on(),[,n]=js([]);return e(()=>n({})),Ft(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),Ft(()=>{Pr.enqueueExecution("Batcher",()=>{Ys(t.current)})}),null}function Js(e,t){const n=ho();return t({set:(o,r)=>{const a=n.currentTree,i=xs(e,a,o.key,r),u=new Set(i.keys()),d=a.nonvalidatedAtoms.clone();for(const f of u)d.delete(f);n.currentTree={...a,dirtyAtoms:$s(a.dirtyAtoms,u),atomValues:Fs(a.atomValues,i),nonvalidatedAtoms:d}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Os(n.currentTree,a,r)})}}),n}function Qs(e){const t=Ws(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let En=0;function ei({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=L=>{const E=r.current.graphsByVersion;if(E.has(L))return j(E.get(L));const $=Bs();return E.set(L,$),$},i=(L,E)=>{if(E==null){const{transactionSubscriptions:$}=g.current.getState(),Q=En++;return $.set(Q,L),{release:()=>{$.delete(Q)}}}else{const{nodeTransactionSubscriptions:$}=g.current.getState();$.has(E)||$.set(E,new Map);const Q=En++;return j($.get(E)).set(Q,L),{release:()=>{const te=$.get(E);te&&(te.delete(Q),te.size===0&&$.delete(E))}}}},u=L=>{wn(g.current);for(const E of Object.keys(L))j(g.current.getState().nextTree).transactionMetadata[E]=L[E]},d=L=>{wn(g.current);const E=j(r.current.nextTree);let $;try{Wt=!0,$=L(E)}finally{Wt=!1}$!==E&&(r.current.nextTree=$,po().early&&Ro(g.current,r.current,$),j(f.current)())},f=Hs(null),p=Ks(L=>{f.current=L},[f]),g=bn(()=>n??{storeID:vo(),getState:()=>r.current,replaceState:d,getGraph:a,subscribeToTransactions:i,addTransactionMetadata:u});n!=null&&(g.current=n),r=bn(()=>e!=null?Js(g.current,e):t!=null?Qs(t):ho());const I=Gs(()=>Dt==null?void 0:Dt(r,()=>r.current.currentTree.version),[r]);return Ft(()=>{const L=g.current;for(const E of new Set(L.getState().knownAtoms))Ps(L,E,"get");return()=>{for(const E of L.getState().knownAtoms)Is(L,E)}},[g]),Z.createElement(So.Provider,{value:g},Z.createElement(go.Provider,{value:I},Z.createElement(Xs,{setNotifyBatcherOfChange:p}),o))}function ti(e){const{override:t,...n}=e,o=on();return t===!1&&o.current!==yo?e.children:Z.createElement(ei,n)}var rn={RecoilRoot:ti,useStoreRef:on,useRecoilMutableSource:qs};function ni(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var oi=ni;const{useEffect:ri,useRef:ai}=Z;function si(e){const t=ai();return ri(()=>{t.current=e}),t.current}var ii=si;const{useStoreRef:li}=rn,{SUSPENSE_TIMEOUT_MS:ci}=Pe,{updateRetainCount:Fe}=Pe,{RetentionZone:ui}=Xt,{useEffect:di,useRef:fi}=Z,{isSSR:Tn}=nn;function hi(e){if(F("recoil_memory_managament_2020"))return vi(e)}function vi(e){const n=(Array.isArray(e)?e:[e]).map(i=>i instanceof ui?i:i.key),o=li();di(()=>{if(!F("recoil_memory_managament_2020"))return;const i=o.current;if(r.current&&!Tn)window.clearTimeout(r.current),r.current=null;else for(const u of n)Fe(i,u,1);return()=>{for(const u of n)Fe(i,u,-1)}},[o,...n]);const r=fi(),a=ii(n);if(!Tn&&(a===void 0||!oi(a,n))){const i=o.current;for(const u of n)Fe(i,u,1);if(a)for(const u of a)Fe(i,u,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const u of n)Fe(i,u,-1)},ci)}}var pi=hi;function _i(){return"<component name not available>"}var bt=_i;const{currentRendererSupportsUseSyncExternalStore:mi,reactMode:et,useMutableSource:yi,useSyncExternalStore:Si}=Ht,{useRecoilMutableSource:gi,useStoreRef:xe}=rn,{isRecoilValue:mc}=Te,{getRecoilValueAsLoadable:wt,setRecoilValue:Ri,subscribeToRecoilValue:Et}=ge,{useCallback:pe,useEffect:dt,useMemo:bi,useRef:bo,useState:wo}=Z,{isSSR:wi}=nn;function Ei(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),wi&&K(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:M(`Invalid value of loadable atom "${t.key}"`)}function Ti(e){const t=xe(),n=bt(),o=pe(()=>{var u;const d=t.current,f=d.getState(),p=et().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return{loadable:wt(d,e,p),key:e.key}},[t,e]),r=pe(u=>{let d;return()=>{var f,p;const g=u();return(f=d)!==null&&f!==void 0&&f.loadable.is(g.loadable)&&((p=d)===null||p===void 0?void 0:p.key)===g.key?d:(d=g,g)}},[]),a=bi(()=>r(o),[o,r]),i=pe(u=>{const d=t.current;return Et(d,e,u,n).release},[t,e,n]);return Si(i,a,a).loadable}function Ai(e){const t=xe(),n=pe(()=>{var f;const p=t.current,g=p.getState(),I=et().early&&(f=g.nextTree)!==null&&f!==void 0?f:g.currentTree;return wt(p,e,I)},[t,e]),o=pe(()=>n(),[n]),r=bt(),a=pe((f,p)=>{const g=t.current;return Et(g,e,()=>{if(!F("recoil_suppress_rerender_in_callback"))return p();const L=n();d.current.is(L)||p(),d.current=L},r).release},[t,e,r,n]),i=gi();if(i==null)throw M("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const u=yi(i,o,a),d=bo(u);return dt(()=>{d.current=u}),u}function An(e){const t=xe(),n=bt(),o=pe(()=>{var d;const f=t.current,p=f.getState(),g=et().early&&(d=p.nextTree)!==null&&d!==void 0?d:p.currentTree;return wt(f,e,g)},[t,e]),r=pe(()=>({loadable:o(),key:e.key}),[o,e.key]),a=pe(d=>{const f=r();return d.loadable.is(f.loadable)&&d.key===f.key?d:f},[r]);dt(()=>{const d=Et(t.current,e,f=>{u(a)},n);return u(a),d.release},[n,e,t,a]);const[i,u]=wo(r);return i.key!==e.key?r().loadable:i.loadable}function Ni(e){const t=xe(),[,n]=wo([]),o=bt(),r=pe(()=>{var u;const d=t.current,f=d.getState(),p=et().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return wt(d,e,p)},[t,e]),a=r(),i=bo(a);return dt(()=>{i.current=a}),dt(()=>{const u=t.current,d=u.getState(),f=Et(u,e,g=>{var I;if(!F("recoil_suppress_rerender_in_callback"))return n([]);const L=r();(I=i.current)!==null&&I!==void 0&&I.is(L)||n(L),i.current=L},o);if(d.nextTree)u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,n([])});else{var p;if(!F("recoil_suppress_rerender_in_callback"))return n([]);const g=r();(p=i.current)!==null&&p!==void 0&&p.is(g)||n(g),i.current=g}return f.release},[o,r,e,t]),a}function Li(e){return F("recoil_memory_managament_2020")&&pi(e),{TRANSITION_SUPPORT:An,SYNC_EXTERNAL_STORE:mi()?Ti:An,MUTABLE_SOURCE:Ai,LEGACY:Ni}[et().mode](e)}function Eo(e){const t=xe(),n=Li(e);return Ei(n,e,t)}function To(e){const t=xe();return pe(n=>{Ri(t.current,e,n)},[t,e])}function Ci(e){return[Eo(e),To(e)]}var Vi={useRecoilState:Ci,useRecoilValue:Eo,useSetRecoilState:To};const{batchUpdates:$i}=tn,{DEFAULT_VALUE:Mi,getNode:ki}=_e,{AbstractRecoilValue:Di,setRecoilValueLoadable:Ii}=ge,{cloneSnapshot:yc}=Rt,{useCallback:Sc,useEffect:gc,useRef:Rc,useState:bc}=Z;function Ui(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;$i(()=>{const i=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const p of f){var u,d;((u=r.atomValues.get(p))===null||u===void 0?void 0:u.contents)!==((d=a.atomValues.get(p))===null||d===void 0?void 0:d.contents)&&ki(p).shouldRestoreFromSnapshots&&i.add(p)}i.forEach(f=>{Ii(e,new Di(f),a.atomValues.has(f)?j(a.atomValues.get(f)):Mi)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}var Pi={gotoSnapshot:Ui};const{useMemo:wc}=Z,{loadableWithValue:xi}=Ye,{initializeNode:Oi}=Ne,{DEFAULT_VALUE:Bi,getNode:zi}=_e,{copyTreeState:Fi,getRecoilValueAsLoadable:Wi,invalidateDownstreams:Ki,writeLoadableToTreeState:Gi}=ge;function Nn(e){return zi(e.key).nodeType==="atom"}class Hi{constructor(t,n){V(this,"_store",void 0),V(this,"_treeState",void 0),V(this,"_changes",void 0),V(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!Nn(o))throw M("Reading selectors within atomicUpdate is not supported");const r=Wi(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:M(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),V(this,"set",(o,r)=>{if(!Nn(o))throw M("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else Oi(this._store,o.key,"set"),this._changes.set(o.key,r)}),V(this,"reset",o=>{this.set(o,Bi)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=Fi(this._treeState);for(const[n,o]of this._changes)Gi(t,n,xi(o));return Ki(this._store,t),t}}function ji(e){return t=>{e.replaceState(n=>{const o=new Hi(e,n);return t(o),o.newTreeState_INTERNAL()})}}var qi={atomicUpdater:ji},Zi=qi.atomicUpdater,Ao=Object.freeze({__proto__:null,atomicUpdater:Zi});function Yi(e,t){if(!e)throw new Error(t)}var Xi=Yi,He=Xi;const{atomicUpdater:Ji}=Ao,{batchUpdates:Qi}=tn,{DEFAULT_VALUE:el}=_e,{refreshRecoilValue:tl,setRecoilValue:Ln}=ge,{cloneSnapshot:nl}=Rt,{gotoSnapshot:ol}=Pi,{useCallback:Ec}=Z;class No{}const rl=new No;function al(e,t,n,o){let r=rl,a;if(Qi(()=>{const u="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw M(u);const d=jn({...o??{},set:(p,g)=>Ln(e,p,g),reset:p=>Ln(e,p,el),refresh:p=>tl(e,p),gotoSnapshot:p=>ol(e,p),transact_UNSTABLE:p=>Ji(e)(p)},{snapshot:()=>{const p=nl(e);return a=p.retain(),p}}),f=t(d);if(typeof f!="function")throw M(u);r=f(...n)}),r instanceof No&&He(!1),K(r))r=r.finally(()=>{var u;(u=a)===null||u===void 0||u()});else{var i;(i=a)===null||i===void 0||i()}return r}var sl={recoilCallback:al};const{useCallback:Tc}=Z,{atomicUpdater:Ac}=Ao,{useMemo:Nc}=Z;class il{constructor(t){V(this,"value",void 0),this.value=t}}var ll={WrappedValue:il},cl=ll.WrappedValue,Lo=Object.freeze({__proto__:null,WrappedValue:cl});class Cn extends Error{}class ul{constructor(t){var n,o,r;V(this,"_name",void 0),V(this,"_numLeafs",void 0),V(this,"_root",void 0),V(this,"_onHit",void 0),V(this,"_onSet",void 0),V(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,i,u,d;let f,p;for(const[Q,te]of t){var g,I,L;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const U=f;if(f=U?U.branches.get(p):w,f=(g=f)!==null&&g!==void 0?g:{type:"branch",nodeKey:Q,parent:U,branches:new Map,branchKey:p},f.type!=="branch"||f.nodeKey!==Q)throw this.invalidCacheError();U==null||U.branches.set(p,f),o==null||(I=o.onNodeVisit)===null||I===void 0||I.call(o,f),p=this._mapNodeValue(te),this._root=(L=this._root)!==null&&L!==void 0?L:f}const E=f?(a=f)===null||a===void 0?void 0:a.branches.get(p):this._root;if(E!=null&&(E.type!=="leaf"||E.branchKey!==p))throw this.invalidCacheError();const $={type:"leaf",value:n,parent:f,branchKey:p};(i=f)===null||i===void 0||i.branches.set(p,$),this._root=(u=this._root)!==null&&u!==void 0?u:$,this._numLeafs++,this._onSet($),o==null||(d=o.onNodeVisit)===null||d===void 0||d.call(o,$)};try{r()}catch(a){if(a instanceof Cn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){throw ie("Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache."+(this._name!=null?` - ${this._name}`:"")),new Cn}}var dl={TreeCache:ul},fl=dl.TreeCache,Co=Object.freeze({__proto__:null,TreeCache:fl});class hl{constructor(t){var n;V(this,"_maxSize",void 0),V(this,"_size",void 0),V(this,"_head",void 0),V(this,"_tail",void 0),V(this,"_map",void 0),V(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),i={key:t,right:a,left:null,value:n};a?a.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=j(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var vl={LRUCache:hl},pl=vl.LRUCache,Vo=Object.freeze({__proto__:null,LRUCache:pl});const{LRUCache:_l}=Vo,{TreeCache:ml}=Co;function yl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new _l({maxSize:t}),r=new ml({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const i=o.tail();o.set(a,!0),i&&r.size()>t&&r.delete(i.key)}});return r}var Vn=yl;function ve(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw M("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(K(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>ve(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return ve(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,i]of e)r[typeof a=="string"?a:ve(a,t)]=i;return ve(r,t,n)}return e instanceof Set?ve(Array.from(e).sort((r,a)=>ve(r,t).localeCompare(ve(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?ve(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${ve(r,t)}:${ve(e[r],t,r)}`).join(",")}}`}function Sl(e,t={allowFunctions:!1}){return ve(e,t)}var an=Sl;const{TreeCache:gl}=Co,rt={equality:"reference",eviction:"keep-all",maxSize:1/0};function Rl({equality:e=rt.equality,eviction:t=rt.eviction,maxSize:n=rt.maxSize}=rt,o){const r=bl(e);return wl(t,n,r,o)}function bl(e){switch(e){case"reference":return t=>t;case"value":return t=>an(t)}throw M(`Unrecognized equality policy ${e}`)}function wl(e,t,n,o){switch(e){case"keep-all":return new gl({name:o,mapNodeValue:n});case"lru":return Vn({name:o,maxSize:j(t),mapNodeValue:n});case"most-recent":return Vn({name:o,maxSize:1,mapNodeValue:n})}throw M(`Unrecognized eviction policy ${e}`)}var El=Rl;const{isLoadable:Tl,loadableWithError:at,loadableWithPromise:Al,loadableWithValue:It}=Ye,{WrappedValue:$o}=Lo,{getNodeLoadable:st,peekNodeLoadable:Nl,setNodeValue:Ll}=Ne,{saveDepsToStore:Cl}=Je,{DEFAULT_VALUE:Vl,getConfigDeletionHandler:$l,getNode:Ml,registerNode:$n}=_e,{isRecoilValue:kl}=Te,{markRecoilValueModified:Mn}=ge,{retainedByOptionWithDefault:Dl}=Pe,{recoilCallback:Il}=sl;class Mo{}const We=new Mo,Ke=[],it=new Map,Ul=(()=>{let e=0;return()=>e++})();function ko(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,i=new Set,u=El(r??{equality:"reference",eviction:"keep-all"},n),d=Dl(e.retainedBy_UNSTABLE),f=new Map;let p=0;function g(){return!F("recoil_memory_managament_2020")||p>0}function I(c){return c.getState().knownSelectors.add(n),p++,()=>{p--}}function L(){return $l(n)!==void 0&&!g()}function E(c,v,_,C,R){de(v,C,R),$(c,_)}function $(c,v){le(c,v)&&X(c),te(v,!0)}function Q(c,v){le(c,v)&&(j(J(c)).stateVersions.clear(),te(v,!1))}function te(c,v){const _=it.get(c);if(_!=null){for(const C of _)Mn(C,j(t));v&&it.delete(c)}}function w(c,v){let _=it.get(v);_==null&&it.set(v,_=new Set),_.add(c)}function U(c,v,_,C,R,k){return v.then(b=>{if(!g())throw X(c),We;const x=It(b);return E(c,_,R,x,C),b}).catch(b=>{if(!g())throw X(c),We;if(K(b))return Y(c,b,_,C,R,k);const x=at(b);throw E(c,_,R,x,C),b})}function Y(c,v,_,C,R,k){return v.then(b=>{if(!g())throw X(c),We;k.loadingDepKey!=null&&k.loadingDepPromise===v?_.atomValues.set(k.loadingDepKey,It(b)):c.getState().knownSelectors.forEach(O=>{_.atomValues.delete(O)});const x=q(c,_);if(x&&x.state!=="loading"){if((le(c,R)||J(c)==null)&&$(c,R),x.state==="hasValue")return x.contents;throw x.contents}if(!le(c,R)){const O=ye(c,_);if(O!=null)return O.loadingLoadable.contents}const[W,ee]=G(c,_,R);if(W.state!=="loading"&&E(c,_,R,W,ee),W.state==="hasError")throw W.contents;return W.contents}).catch(b=>{if(b instanceof Mo)throw We;if(!g())throw X(c),We;const x=at(b);throw E(c,_,R,x,C),b})}function z(c,v,_,C){var R,k,b,x;if(le(c,C)||v.version===((R=c.getState())===null||R===void 0||(k=R.currentTree)===null||k===void 0?void 0:k.version)||v.version===((b=c.getState())===null||b===void 0||(x=b.nextTree)===null||x===void 0?void 0:x.version)){var W,ee,O;Cl(n,_,c,(W=(ee=c.getState())===null||ee===void 0||(O=ee.nextTree)===null||O===void 0?void 0:O.version)!==null&&W!==void 0?W:c.getState().currentTree.version)}for(const ne of _)i.add(ne)}function G(c,v,_){let C=!0,R=!0;const k=()=>{R=!1};let b,x=!1,W;const ee={loadingDepKey:null,loadingDepPromise:null},O=new Map;function ne({key:ce}){const ae=st(c,v,ce);switch(O.set(ce,ae),C||(z(c,v,new Set(O.keys()),_),Q(c,_)),ae.state){case"hasValue":return ae.contents;case"hasError":throw ae.contents;case"loading":throw ee.loadingDepKey=ce,ee.loadingDepPromise=ae.contents,ae.contents}throw M("Invalid Loadable state")}const me=ce=>(...ae)=>{if(R)throw M("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&He(!1),Il(c,ce,ae,{node:t})};try{b=o({get:ne,getCallback:me}),b=kl(b)?ne(b):b,Tl(b)&&(b.state==="hasError"&&(x=!0),b=b.contents),K(b)?b=U(c,b,v,O,_,ee).finally(k):k(),b=b instanceof $o?b.value:b}catch(ce){b=ce,K(b)?b=Y(c,b,v,O,_,ee).finally(k):(x=!0,k())}return x?W=at(b):K(b)?W=Al(b):W=It(b),C=!1,Ce(c,_,O),z(c,v,new Set(O.keys()),_),[W,O]}function q(c,v){let _=v.atomValues.get(n);if(_!=null)return _;const C=new Set;try{_=u.get(k=>(typeof k!="string"&&He(!1),st(c,v,k).contents),{onNodeVisit:k=>{k.type==="branch"&&k.nodeKey!==n&&C.add(k.nodeKey)}})}catch(k){throw M(`Problem with cache lookup for selector "${n}": ${k.message}`)}if(_){var R;v.atomValues.set(n,_),z(c,v,C,(R=J(c))===null||R===void 0?void 0:R.executionID)}return _}function re(c,v){const _=q(c,v);if(_!=null)return X(c),_;const C=ye(c,v);if(C!=null){var R;return((R=C.loadingLoadable)===null||R===void 0?void 0:R.state)==="loading"&&w(c,C.executionID),C.loadingLoadable}const k=Ul(),[b,x]=G(c,v,k);return b.state==="loading"?(ue(c,k,b,x,v),w(c,k)):(X(c),de(v,b,x)),b}function ye(c,v){const _=co([f.has(c)?[j(f.get(c))]:[],_t(Jt(f,([R])=>R!==c),([,R])=>R)]);function C(R){for(const[k,b]of R)if(!st(c,v,k).is(b))return!0;return!1}for(const R of _){if(R.stateVersions.get(v.version)||!C(R.depValuesDiscoveredSoFarDuringAsyncWork))return R.stateVersions.set(v.version,!0),R;R.stateVersions.set(v.version,!1)}}function J(c){return f.get(c)}function ue(c,v,_,C,R){f.set(c,{depValuesDiscoveredSoFarDuringAsyncWork:C,executionID:v,loadingLoadable:_,stateVersions:new Map([[R.version,!0]])})}function Ce(c,v,_){if(le(c,v)){const C=J(c);C!=null&&(C.depValuesDiscoveredSoFarDuringAsyncWork=_)}}function X(c){f.delete(c)}function le(c,v){var _;return v===((_=J(c))===null||_===void 0?void 0:_.executionID)}function be(c){return Array.from(c.entries()).map(([v,_])=>[v,_.contents])}function de(c,v,_){c.atomValues.set(n,v);try{u.set(be(_),v)}catch(C){throw M(`Problem with setting cache for selector "${n}": ${C.message}`)}}function Se(c){if(Ke.includes(n)){const v=`Recoil selector has circular dependencies: ${Ke.slice(Ke.indexOf(n)).join("  ")}`;return at(M(v))}Ke.push(n);try{return c()}finally{Ke.pop()}}function Ve(c,v){const _=v.atomValues.get(n);return _??u.get(C=>{var R;return typeof C!="string"&&He(!1),(R=Nl(c,v,C))===null||R===void 0?void 0:R.contents})}function $e(c,v){return Se(()=>re(c,v))}function P(c){c.atomValues.delete(n)}function B(c,v){t==null&&He(!1);for(const C of i){var _;const R=Ml(C);(_=R.clearCache)===null||_===void 0||_.call(R,c,v)}i.clear(),P(v),u.clear(),Mn(c,t)}return a!=null?t=$n({key:n,nodeType:"selector",peek:Ve,get:$e,set:(v,_,C)=>{let R=!1;const k=new Map;function b({key:O}){if(R)throw M("Recoil: Async selector sets are not currently supported.");const ne=st(v,_,O);if(ne.state==="hasValue")return ne.contents;if(ne.state==="loading"){const me=`Getting value of asynchronous atom or selector "${O}" in a pending state while setting selector "${n}" is not yet supported.`;throw ie(),M(me)}else throw ne.contents}function x(O,ne){if(R){const ae="Recoil: Async selector sets are not currently supported.";throw ie(),M(ae)}const me=typeof ne=="function"?ne(b(O)):ne;Ll(v,_,O.key,me).forEach((ae,nt)=>k.set(nt,ae))}function W(O){x(O,Vl)}const ee=a({set:x,get:b,reset:W},C);if(ee!==void 0)throw K(ee)?M("Recoil: Async selector sets are not currently supported."):M("Recoil: selector set should be a void function.");return R=!0,k},init:I,invalidate:P,clearCache:B,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d}):t=$n({key:n,nodeType:"selector",peek:Ve,get:$e,init:I,invalidate:P,clearCache:B,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}ko.value=e=>new $o(e);var qe=ko;const{isLoadable:Pl,loadableWithError:Ut,loadableWithPromise:Pt,loadableWithValue:ke}=Ye,{WrappedValue:Do}=Lo,{peekNodeInfo:xl}=Ne,{DEFAULT_VALUE:we,DefaultValue:Re,getConfigDeletionHandler:Io,registerNode:Ol,setConfigDeletionHandler:Bl}=_e,{isRecoilValue:zl}=Te,{getRecoilValueAsLoadable:Fl,markRecoilValueModified:Wl,setRecoilValue:kn,setRecoilValueLoadable:Kl}=ge,{retainedByOptionWithDefault:Gl}=Pe,Ge=e=>e instanceof Do?e.value:e;function Hl(e){const{key:t,persistence_UNSTABLE:n}=e,o=Gl(e.retainedBy_UNSTABLE);let r=0;function a(w){return Pt(w.then(U=>(i=ke(U),U)).catch(U=>{throw i=Ut(U),U}))}let i=K(e.default)?a(e.default):Pl(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:ke(Ge(e.default));i.contents;let u;const d=new Map;function f(w){return w}function p(w,U){const Y=U.then(z=>{var G,q;return((q=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||q===void 0?void 0:q.contents)===Y&&kn(w,te,z),z}).catch(z=>{var G,q;throw((q=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||q===void 0?void 0:q.contents)===Y&&Kl(w,te,Ut(z)),z});return Y}function g(w,U,Y){var z;r++;const G=()=>{var J;r--,(J=d.get(w))===null||J===void 0||J.forEach(ue=>ue()),d.delete(w)};if(w.getState().knownAtoms.add(t),i.state==="loading"){const J=()=>{var ue;((ue=w.getState().nextTree)!==null&&ue!==void 0?ue:w.getState().currentTree).atomValues.has(t)||Wl(w,te)};i.contents.finally(J)}const q=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(q!=null){let J=function(P){if(le&&P.key===t){const B=X;return B instanceof Re?I(w,U):K(B)?Pt(B.then(c=>c instanceof Re?i.toPromise():c)):ke(B)}return Fl(w,P)},ue=function(P){return J(P).toPromise()},Ce=function(P){var B;const c=xl(w,(B=w.getState().nextTree)!==null&&B!==void 0?B:w.getState().currentTree,P.key);return le&&P.key===t&&!(X instanceof Re)?{...c,isSet:!0,loadable:J(P)}:c},X=we,le=!0,be=!1,de=null;const Se=P=>B=>{if(le){const c=J(te),v=c.state==="hasValue"?c.contents:we;X=typeof B=="function"?B(v):B,K(X)&&(X=X.then(_=>(de={effect:P,value:_},_)))}else{if(K(B))throw M("Setting atoms to async values is not implemented.");typeof B!="function"&&(de={effect:P,value:Ge(B)}),kn(w,te,typeof B=="function"?c=>{const v=Ge(B(c));return de={effect:P,value:v},v}:Ge(B))}},Ve=P=>()=>Se(P)(we),$e=P=>B=>{var c;const{release:v}=w.subscribeToTransactions(_=>{var C;let{currentTree:R,previousTree:k}=_.getState();k||(ie(),k=R);const b=(C=R.atomValues.get(t))!==null&&C!==void 0?C:i;if(b.state==="hasValue"){var x,W,ee,O;const ne=b.contents,me=(x=k.atomValues.get(t))!==null&&x!==void 0?x:i,ce=me.state==="hasValue"?me.contents:we;((W=de)===null||W===void 0?void 0:W.effect)!==P||((ee=de)===null||ee===void 0?void 0:ee.value)!==ne?B(ne,ce,!R.atomValues.has(t)):((O=de)===null||O===void 0?void 0:O.effect)===P&&(de=null)}},t);d.set(w,[...(c=d.get(w))!==null&&c!==void 0?c:[],v])};for(const P of q)try{const B=P({node:te,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:Y,setSelf:Se(P),resetSelf:Ve(P),onSet:$e(P),getPromise:ue,getLoadable:J,getInfo_UNSTABLE:Ce});if(B!=null){var re;d.set(w,[...(re=d.get(w))!==null&&re!==void 0?re:[],B])}}catch(B){X=B,be=!0}if(le=!1,!(X instanceof Re)){var ye;const P=be?Ut(X):K(X)?Pt(p(w,X)):ke(Ge(X));P.contents,U.atomValues.set(t,P),(ye=w.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return G}function I(w,U){var Y,z;return(Y=(z=U.atomValues.get(t))!==null&&z!==void 0?z:u)!==null&&Y!==void 0?Y:i}function L(w,U){if(U.atomValues.has(t))return j(U.atomValues.get(t));if(U.nonvalidatedAtoms.has(t)){if(u!=null)return u;if(n==null)return Fn(),i;const Y=U.nonvalidatedAtoms.get(t),z=n.validator(Y,we);return u=z instanceof Re?i:ke(z),u}else return i}function E(){u=void 0}function $(w,U,Y){if(U.atomValues.has(t)){const z=j(U.atomValues.get(t));if(z.state==="hasValue"&&Y===z.contents)return new Map}else if(!U.nonvalidatedAtoms.has(t)&&Y instanceof Re)return new Map;return u=void 0,new Map().set(t,ke(Y))}function Q(){return Io(t)!==void 0&&r<=0}const te=Ol({key:t,nodeType:"atom",peek:I,get:L,set:$,init:g,invalidate:E,shouldDeleteConfigOnRelease:Q,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return te}function sn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return zl(n)?jl({...t,default:n}):Hl({...t,default:n})}function jl(e){const t=sn({...e,default:we,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Re?o:j(e.persistence_UNSTABLE).validator(o,we)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=qe({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof Re?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Bl(n.key,Io(e.key)),n}sn.value=e=>new Do(e);var ql=sn;class Zl{constructor(t){var n;V(this,"_map",void 0),V(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Yl={MapCache:Zl},Xl=Yl.MapCache,Jl=Object.freeze({__proto__:null,MapCache:Xl});const{LRUCache:Dn}=Vo,{MapCache:Ql}=Jl,lt={equality:"reference",eviction:"none",maxSize:1/0};function ec({equality:e=lt.equality,eviction:t=lt.eviction,maxSize:n=lt.maxSize}=lt){const o=tc(e);return nc(t,n,o)}function tc(e){switch(e){case"reference":return t=>t;case"value":return t=>an(t)}throw M(`Unrecognized equality policy ${e}`)}function nc(e,t,n){switch(e){case"keep-all":return new Ql({mapKey:n});case"lru":return new Dn({mapKey:n,maxSize:j(t)});case"most-recent":return new Dn({mapKey:n,maxSize:1})}throw M(`Unrecognized eviction policy ${e}`)}var oc=ec;const{setConfigDeletionHandler:rc}=_e;let ac=0;function sc(e){var t,n;const o=oc({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let i;try{i=o.get(r)}catch(I){throw M(`Problem with cache lookup for selector ${e.key}: ${I.message}`)}if(i!=null)return i;const u=`${e.key}__selectorFamily/${(a=an(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${ac++}`,d=I=>e.get(r)(I),f=e.cachePolicy_UNSTABLE,p=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let g;if(e.set!=null){const I=e.set;g=qe({key:u,get:d,set:(E,$)=>I(r)(E,$),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:p})}else g=qe({key:u,get:d,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:p});return o.set(r,g),rc(g.key,()=>{o.delete(r)}),g}}var Le=sc;Le({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});Le({key:"__error",get:e=>()=>{throw M(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});const{loadableWithError:Uo,loadableWithPromise:Po,loadableWithValue:xo}=Ye;function Tt(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(i){o[r]=i}return[n,o]}function ic(e){return e!=null&&!K(e)}function At(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function Kt(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function De(e,t,n){const o=n.map((r,a)=>r==null?xo(t[a]):K(r)?Po(r):Uo(r));return Kt(e,o)}function lc(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}Le({key:"__waitForNone",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return De(e,o,r)},dangerouslyAllowMutability:!0});Le({key:"__waitForAny",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return r.some(a=>!K(a))?De(e,o,r):new Promise(a=>{for(const[i,u]of r.entries())K(u)&&u.then(d=>{o[i]=d,r[i]=void 0,a(De(e,o,r))}).catch(d=>{r[i]=d,a(De(e,o,r))})})},dangerouslyAllowMutability:!0});Le({key:"__waitForAll",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);if(r.every(i=>i==null))return Kt(e,o);const a=r.find(ic);if(a!=null)throw a;return Promise.all(r).then(i=>Kt(e,lc(o,i)))},dangerouslyAllowMutability:!0});Le({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=At(e),[o,r]=Tt(t,n);return r.every(a=>!K(a))?De(e,o,r):Promise.all(r.map((a,i)=>K(a)?a.then(u=>{o[i]=u,r[i]=void 0}).catch(u=>{o[i]=void 0,r[i]=u}):null)).then(()=>De(e,o,r))},dangerouslyAllowMutability:!0});Le({key:"__noWait",get:e=>({get:t})=>{try{return qe.value(xo(t(e)))}catch(n){return qe.value(K(n)?Po(n):Uo(n))}},dangerouslyAllowMutability:!0});const{RecoilLoadable:Lc}=Ye,{RecoilRoot:cc}=rn,{isRecoilValue:Cc}=Te,{freshSnapshot:Vc}=Rt,{useRecoilState:uc,useRecoilValue:dc,useSetRecoilState:fc}=Vi;var tt={RecoilRoot:cc,atom:ql,useRecoilValue:dc,useRecoilState:uc,useSetRecoilState:fc},$c=tt.RecoilRoot,Mc=tt.atom,kc=tt.useRecoilValue,Dc=tt.useRecoilState,Ic=tt.useSetRecoilState;export{Mc as R,Ic as a,kc as b,$c as c,Dc as d};
